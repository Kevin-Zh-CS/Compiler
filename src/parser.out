Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    BREAK
    CONTINUE
    EXIT
    RECORD
    RETURN
    TYPE

Grammar

Rule 0     S' -> program
Rule 1     program -> PROGRAM ID ; body .
Rule 2     body -> local_list compound_stmt
Rule 3     local_list -> local_list local
Rule 4     local_list -> empty
Rule 5     local -> VAR var_list
Rule 6     local -> LABEL id_list ;
Rule 7     local -> CONST const_exp_list
Rule 8     local -> header ; body ;
Rule 9     var_list -> var_list var
Rule 10    var_list -> var
Rule 11    var -> id_list : vartype ;
Rule 12    var -> id_list : vartype EQ exp ;
Rule 13    const_exp_list -> const_exp_list const_exp
Rule 14    const_exp_list -> const_exp
Rule 15    const_exp -> id_list EQ literal ;
Rule 16    id_list -> ID comma_id_list
Rule 17    comma_id_list -> comma_id_list , ID
Rule 18    comma_id_list -> empty
Rule 19    header -> PROCEDURE ID ( formal_list )
Rule 20    header -> PROCEDURE ID ( )
Rule 21    header -> FUNCTION ID ( formal_list ) : vartype
Rule 22    header -> FUNCTION ID ( ) : vartype
Rule 23    formal_list -> formal semicolon_formal_list
Rule 24    formal -> id_list : vartype
Rule 25    semicolon_formal_list -> semicolon_formal_list ; formal
Rule 26    semicolon_formal_list -> empty
Rule 27    vartype -> INT
Rule 28    vartype -> REAL
Rule 29    vartype -> BOOL
Rule 30    vartype -> CHAR
Rule 31    vartype -> STRING
Rule 32    vartype -> ARRAY [ LITERAL_INT ] OF vartype
Rule 33    vartype -> ARRAY [ LITERAL_INT RANGE LITERAL_INT ] OF vartype
Rule 34    semicolon_stmt_list -> semicolon_stmt_list ; stmt
Rule 35    semicolon_stmt_list -> empty
Rule 36    stmt -> ID : non_label_stmt
Rule 37    stmt -> non_label_stmt
Rule 38    non_label_stmt -> assign_stmt
Rule 39    non_label_stmt -> call_stmt
Rule 40    non_label_stmt -> for_stmt
Rule 41    non_label_stmt -> if_stmt
Rule 42    non_label_stmt -> while_stmt
Rule 43    non_label_stmt -> repeat_stmt
Rule 44    non_label_stmt -> case_stmt
Rule 45    non_label_stmt -> goto_stmt
Rule 46    non_label_stmt -> compound_stmt
Rule 47    assign_stmt -> lvalue ASSIGN exp
Rule 48    for_stmt -> FOR ID ASSIGN exp direction exp DO stmt
Rule 49    direction -> DOWNTO
Rule 50    direction -> TO
Rule 51    while_stmt -> WHILE exp DO stmt
Rule 52    repeat_stmt -> REPEAT stmt semicolon_stmt_list UNTIL exp
Rule 53    case_stmt -> CASE exp OF case_exp_list END
Rule 54    case_exp_list -> case_exp_list ; case_exp
Rule 55    case_exp_list -> case_exp
Rule 56    case_exp -> literal : stmt
Rule 57    case_exp -> ID : stmt
Rule 58    goto_stmt -> GOTO ID
Rule 59    compound_stmt -> BEGIN stmt semicolon_stmt_list END
Rule 60    call_stmt -> ID ( exp comma_exp_list )
Rule 61    call_stmt -> vartype ( exp )
Rule 62    call_stmt -> ID ( )
Rule 63    comma_exp_list -> comma_exp_list , exp
Rule 64    comma_exp_list -> empty
Rule 65    if_stmt -> IF exp THEN stmt else_stmt
Rule 66    else_stmt -> ELSE stmt
Rule 67    else_stmt -> empty
Rule 68    lvalue -> ID
Rule 69    lvalue -> ID [ exp ]
Rule 70    literal -> LITERAL_INT
Rule 71    literal -> LITERAL_REAL
Rule 72    literal -> LITERAL_BOOL
Rule 73    literal -> LITERAL_CHAR
Rule 74    literal -> LITERAL_STRING
Rule 75    exp -> call_stmt
Rule 76    exp -> exp + exp
Rule 77    exp -> exp - exp
Rule 78    exp -> exp * exp
Rule 79    exp -> exp / exp
Rule 80    exp -> exp % exp
Rule 81    exp -> exp EQ exp
Rule 82    exp -> exp NEQ exp
Rule 83    exp -> exp LT exp
Rule 84    exp -> exp GT exp
Rule 85    exp -> exp LEQ exp
Rule 86    exp -> exp GEQ exp
Rule 87    exp -> exp AND exp
Rule 88    exp -> exp OR exp
Rule 89    exp -> NOT exp
Rule 90    exp -> - exp
Rule 91    exp -> + exp
Rule 92    exp -> ( exp )
Rule 93    exp -> ID
Rule 94    exp -> literal
Rule 95    exp -> ID [ exp ]
Rule 96    empty -> <empty>

Terminals, with rules where they appear

%                    : 80
(                    : 19 20 21 22 60 61 62 92
)                    : 19 20 21 22 60 61 62 92
*                    : 78
+                    : 76 91
,                    : 17 63
-                    : 77 90
.                    : 1
/                    : 79
:                    : 11 12 21 22 24 36 56 57
;                    : 1 6 8 8 11 12 15 25 34 54
AND                  : 87
ARRAY                : 32 33
ASSIGN               : 47 48
BEGIN                : 59
BOOL                 : 29
BREAK                : 
CASE                 : 53
CHAR                 : 30
CONST                : 7
CONTINUE             : 
DO                   : 48 51
DOWNTO               : 49
ELSE                 : 66
END                  : 53 59
EQ                   : 12 15 81
EXIT                 : 
FOR                  : 48
FUNCTION             : 21 22
GEQ                  : 86
GOTO                 : 58
GT                   : 84
ID                   : 1 16 17 19 20 21 22 36 48 57 58 60 62 68 69 93 95
IF                   : 65
INT                  : 27
LABEL                : 6
LEQ                  : 85
LITERAL_BOOL         : 72
LITERAL_CHAR         : 73
LITERAL_INT          : 32 33 33 70
LITERAL_REAL         : 71
LITERAL_STRING       : 74
LT                   : 83
NEQ                  : 82
NOT                  : 89
OF                   : 32 33 53
OR                   : 88
PROCEDURE            : 19 20
PROGRAM              : 1
RANGE                : 33
REAL                 : 28
RECORD               : 
REPEAT               : 52
RETURN               : 
STRING               : 31
THEN                 : 65
TO                   : 50
TYPE                 : 
UNTIL                : 52
VAR                  : 5
WHILE                : 51
[                    : 32 33 69 95
]                    : 32 33 69 95
error                : 

Nonterminals, with rules where they appear

assign_stmt          : 38
body                 : 1 8
call_stmt            : 39 75
case_exp             : 54 55
case_exp_list        : 53 54
case_stmt            : 44
comma_exp_list       : 60 63
comma_id_list        : 16 17
compound_stmt        : 2 46
const_exp            : 13 14
const_exp_list       : 7 13
direction            : 48
else_stmt            : 65
empty                : 4 18 26 35 64 67
exp                  : 12 47 48 48 51 52 53 60 61 63 65 69 76 76 77 77 78 78 79 79 80 80 81 81 82 82 83 83 84 84 85 85 86 86 87 87 88 88 89 90 91 92 95
for_stmt             : 40
formal               : 23 25
formal_list          : 19 21
goto_stmt            : 45
header               : 8
id_list              : 6 11 12 15 24
if_stmt              : 41
literal              : 15 56 94
local                : 3
local_list           : 2 3
lvalue               : 47
non_label_stmt       : 36 37
program              : 0
repeat_stmt          : 43
semicolon_formal_list : 23 25
semicolon_stmt_list  : 34 52 59
stmt                 : 34 48 51 52 56 57 59 65 66
var                  : 9 10
var_list             : 5 9
vartype              : 11 12 21 22 24 32 33 61
while_stmt           : 42

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . PROGRAM ID ; body .

    PROGRAM         shift and go to state 2

    program                        shift and go to state 1

state 1

    (0) S' -> program .



state 2

    (1) program -> PROGRAM . ID ; body .

    ID              shift and go to state 3


state 3

    (1) program -> PROGRAM ID . ; body .

    ;               shift and go to state 4


state 4

    (1) program -> PROGRAM ID ; . body .
    (2) body -> . local_list compound_stmt
    (3) local_list -> . local_list local
    (4) local_list -> . empty
    (96) empty -> .

    BEGIN           reduce using rule 96 (empty -> .)
    VAR             reduce using rule 96 (empty -> .)
    LABEL           reduce using rule 96 (empty -> .)
    CONST           reduce using rule 96 (empty -> .)
    PROCEDURE       reduce using rule 96 (empty -> .)
    FUNCTION        reduce using rule 96 (empty -> .)

    body                           shift and go to state 5
    local_list                     shift and go to state 6
    empty                          shift and go to state 7

state 5

    (1) program -> PROGRAM ID ; body . .

    .               shift and go to state 8


state 6

    (2) body -> local_list . compound_stmt
    (3) local_list -> local_list . local
    (59) compound_stmt -> . BEGIN stmt semicolon_stmt_list END
    (5) local -> . VAR var_list
    (6) local -> . LABEL id_list ;
    (7) local -> . CONST const_exp_list
    (8) local -> . header ; body ;
    (19) header -> . PROCEDURE ID ( formal_list )
    (20) header -> . PROCEDURE ID ( )
    (21) header -> . FUNCTION ID ( formal_list ) : vartype
    (22) header -> . FUNCTION ID ( ) : vartype

    BEGIN           shift and go to state 11
    VAR             shift and go to state 12
    LABEL           shift and go to state 13
    CONST           shift and go to state 14
    PROCEDURE       shift and go to state 16
    FUNCTION        shift and go to state 17

    compound_stmt                  shift and go to state 9
    local                          shift and go to state 10
    header                         shift and go to state 15

state 7

    (4) local_list -> empty .

    BEGIN           reduce using rule 4 (local_list -> empty .)
    VAR             reduce using rule 4 (local_list -> empty .)
    LABEL           reduce using rule 4 (local_list -> empty .)
    CONST           reduce using rule 4 (local_list -> empty .)
    PROCEDURE       reduce using rule 4 (local_list -> empty .)
    FUNCTION        reduce using rule 4 (local_list -> empty .)


state 8

    (1) program -> PROGRAM ID ; body . .

    $end            reduce using rule 1 (program -> PROGRAM ID ; body . .)


state 9

    (2) body -> local_list compound_stmt .

    .               reduce using rule 2 (body -> local_list compound_stmt .)
    ;               reduce using rule 2 (body -> local_list compound_stmt .)


state 10

    (3) local_list -> local_list local .

    BEGIN           reduce using rule 3 (local_list -> local_list local .)
    VAR             reduce using rule 3 (local_list -> local_list local .)
    LABEL           reduce using rule 3 (local_list -> local_list local .)
    CONST           reduce using rule 3 (local_list -> local_list local .)
    PROCEDURE       reduce using rule 3 (local_list -> local_list local .)
    FUNCTION        reduce using rule 3 (local_list -> local_list local .)


state 11

    (59) compound_stmt -> BEGIN . stmt semicolon_stmt_list END
    (36) stmt -> . ID : non_label_stmt
    (37) stmt -> . non_label_stmt
    (38) non_label_stmt -> . assign_stmt
    (39) non_label_stmt -> . call_stmt
    (40) non_label_stmt -> . for_stmt
    (41) non_label_stmt -> . if_stmt
    (42) non_label_stmt -> . while_stmt
    (43) non_label_stmt -> . repeat_stmt
    (44) non_label_stmt -> . case_stmt
    (45) non_label_stmt -> . goto_stmt
    (46) non_label_stmt -> . compound_stmt
    (47) assign_stmt -> . lvalue ASSIGN exp
    (60) call_stmt -> . ID ( exp comma_exp_list )
    (61) call_stmt -> . vartype ( exp )
    (62) call_stmt -> . ID ( )
    (48) for_stmt -> . FOR ID ASSIGN exp direction exp DO stmt
    (65) if_stmt -> . IF exp THEN stmt else_stmt
    (51) while_stmt -> . WHILE exp DO stmt
    (52) repeat_stmt -> . REPEAT stmt semicolon_stmt_list UNTIL exp
    (53) case_stmt -> . CASE exp OF case_exp_list END
    (58) goto_stmt -> . GOTO ID
    (59) compound_stmt -> . BEGIN stmt semicolon_stmt_list END
    (68) lvalue -> . ID
    (69) lvalue -> . ID [ exp ]
    (27) vartype -> . INT
    (28) vartype -> . REAL
    (29) vartype -> . BOOL
    (30) vartype -> . CHAR
    (31) vartype -> . STRING
    (32) vartype -> . ARRAY [ LITERAL_INT ] OF vartype
    (33) vartype -> . ARRAY [ LITERAL_INT RANGE LITERAL_INT ] OF vartype

    ID              shift and go to state 19
    FOR             shift and go to state 32
    IF              shift and go to state 33
    WHILE           shift and go to state 34
    REPEAT          shift and go to state 35
    CASE            shift and go to state 36
    GOTO            shift and go to state 37
    BEGIN           shift and go to state 11
    INT             shift and go to state 38
    REAL            shift and go to state 39
    BOOL            shift and go to state 40
    CHAR            shift and go to state 41
    STRING          shift and go to state 42
    ARRAY           shift and go to state 43

    stmt                           shift and go to state 18
    non_label_stmt                 shift and go to state 20
    assign_stmt                    shift and go to state 21
    call_stmt                      shift and go to state 22
    for_stmt                       shift and go to state 23
    if_stmt                        shift and go to state 24
    while_stmt                     shift and go to state 25
    repeat_stmt                    shift and go to state 26
    case_stmt                      shift and go to state 27
    goto_stmt                      shift and go to state 28
    compound_stmt                  shift and go to state 29
    lvalue                         shift and go to state 30
    vartype                        shift and go to state 31

state 12

    (5) local -> VAR . var_list
    (9) var_list -> . var_list var
    (10) var_list -> . var
    (11) var -> . id_list : vartype ;
    (12) var -> . id_list : vartype EQ exp ;
    (16) id_list -> . ID comma_id_list

    ID              shift and go to state 47

    var_list                       shift and go to state 44
    var                            shift and go to state 45
    id_list                        shift and go to state 46

state 13

    (6) local -> LABEL . id_list ;
    (16) id_list -> . ID comma_id_list

    ID              shift and go to state 47

    id_list                        shift and go to state 48

state 14

    (7) local -> CONST . const_exp_list
    (13) const_exp_list -> . const_exp_list const_exp
    (14) const_exp_list -> . const_exp
    (15) const_exp -> . id_list EQ literal ;
    (16) id_list -> . ID comma_id_list

    ID              shift and go to state 47

    const_exp_list                 shift and go to state 49
    const_exp                      shift and go to state 50
    id_list                        shift and go to state 51

state 15

    (8) local -> header . ; body ;

    ;               shift and go to state 52


state 16

    (19) header -> PROCEDURE . ID ( formal_list )
    (20) header -> PROCEDURE . ID ( )

    ID              shift and go to state 53


state 17

    (21) header -> FUNCTION . ID ( formal_list ) : vartype
    (22) header -> FUNCTION . ID ( ) : vartype

    ID              shift and go to state 54


state 18

    (59) compound_stmt -> BEGIN stmt . semicolon_stmt_list END
    (34) semicolon_stmt_list -> . semicolon_stmt_list ; stmt
    (35) semicolon_stmt_list -> . empty
    (96) empty -> .

    END             reduce using rule 96 (empty -> .)
    ;               reduce using rule 96 (empty -> .)

    semicolon_stmt_list            shift and go to state 55
    empty                          shift and go to state 56

state 19

    (36) stmt -> ID . : non_label_stmt
    (60) call_stmt -> ID . ( exp comma_exp_list )
    (62) call_stmt -> ID . ( )
    (68) lvalue -> ID .
    (69) lvalue -> ID . [ exp ]

    :               shift and go to state 57
    (               shift and go to state 58
    ASSIGN          reduce using rule 68 (lvalue -> ID .)
    [               shift and go to state 59


state 20

    (37) stmt -> non_label_stmt .

    END             reduce using rule 37 (stmt -> non_label_stmt .)
    ;               reduce using rule 37 (stmt -> non_label_stmt .)
    UNTIL           reduce using rule 37 (stmt -> non_label_stmt .)
    ELSE            reduce using rule 37 (stmt -> non_label_stmt .)


state 21

    (38) non_label_stmt -> assign_stmt .

    END             reduce using rule 38 (non_label_stmt -> assign_stmt .)
    ;               reduce using rule 38 (non_label_stmt -> assign_stmt .)
    UNTIL           reduce using rule 38 (non_label_stmt -> assign_stmt .)
    ELSE            reduce using rule 38 (non_label_stmt -> assign_stmt .)


state 22

    (39) non_label_stmt -> call_stmt .

    END             reduce using rule 39 (non_label_stmt -> call_stmt .)
    ;               reduce using rule 39 (non_label_stmt -> call_stmt .)
    UNTIL           reduce using rule 39 (non_label_stmt -> call_stmt .)
    ELSE            reduce using rule 39 (non_label_stmt -> call_stmt .)


state 23

    (40) non_label_stmt -> for_stmt .

    END             reduce using rule 40 (non_label_stmt -> for_stmt .)
    ;               reduce using rule 40 (non_label_stmt -> for_stmt .)
    UNTIL           reduce using rule 40 (non_label_stmt -> for_stmt .)
    ELSE            reduce using rule 40 (non_label_stmt -> for_stmt .)


state 24

    (41) non_label_stmt -> if_stmt .

    END             reduce using rule 41 (non_label_stmt -> if_stmt .)
    ;               reduce using rule 41 (non_label_stmt -> if_stmt .)
    UNTIL           reduce using rule 41 (non_label_stmt -> if_stmt .)
    ELSE            reduce using rule 41 (non_label_stmt -> if_stmt .)


state 25

    (42) non_label_stmt -> while_stmt .

    END             reduce using rule 42 (non_label_stmt -> while_stmt .)
    ;               reduce using rule 42 (non_label_stmt -> while_stmt .)
    UNTIL           reduce using rule 42 (non_label_stmt -> while_stmt .)
    ELSE            reduce using rule 42 (non_label_stmt -> while_stmt .)


state 26

    (43) non_label_stmt -> repeat_stmt .

    END             reduce using rule 43 (non_label_stmt -> repeat_stmt .)
    ;               reduce using rule 43 (non_label_stmt -> repeat_stmt .)
    UNTIL           reduce using rule 43 (non_label_stmt -> repeat_stmt .)
    ELSE            reduce using rule 43 (non_label_stmt -> repeat_stmt .)


state 27

    (44) non_label_stmt -> case_stmt .

    END             reduce using rule 44 (non_label_stmt -> case_stmt .)
    ;               reduce using rule 44 (non_label_stmt -> case_stmt .)
    UNTIL           reduce using rule 44 (non_label_stmt -> case_stmt .)
    ELSE            reduce using rule 44 (non_label_stmt -> case_stmt .)


state 28

    (45) non_label_stmt -> goto_stmt .

    END             reduce using rule 45 (non_label_stmt -> goto_stmt .)
    ;               reduce using rule 45 (non_label_stmt -> goto_stmt .)
    UNTIL           reduce using rule 45 (non_label_stmt -> goto_stmt .)
    ELSE            reduce using rule 45 (non_label_stmt -> goto_stmt .)


state 29

    (46) non_label_stmt -> compound_stmt .

    END             reduce using rule 46 (non_label_stmt -> compound_stmt .)
    ;               reduce using rule 46 (non_label_stmt -> compound_stmt .)
    UNTIL           reduce using rule 46 (non_label_stmt -> compound_stmt .)
    ELSE            reduce using rule 46 (non_label_stmt -> compound_stmt .)


state 30

    (47) assign_stmt -> lvalue . ASSIGN exp

    ASSIGN          shift and go to state 60


state 31

    (61) call_stmt -> vartype . ( exp )

    (               shift and go to state 61


state 32

    (48) for_stmt -> FOR . ID ASSIGN exp direction exp DO stmt

    ID              shift and go to state 62


state 33

    (65) if_stmt -> IF . exp THEN stmt else_stmt
    (75) exp -> . call_stmt
    (76) exp -> . exp + exp
    (77) exp -> . exp - exp
    (78) exp -> . exp * exp
    (79) exp -> . exp / exp
    (80) exp -> . exp % exp
    (81) exp -> . exp EQ exp
    (82) exp -> . exp NEQ exp
    (83) exp -> . exp LT exp
    (84) exp -> . exp GT exp
    (85) exp -> . exp LEQ exp
    (86) exp -> . exp GEQ exp
    (87) exp -> . exp AND exp
    (88) exp -> . exp OR exp
    (89) exp -> . NOT exp
    (90) exp -> . - exp
    (91) exp -> . + exp
    (92) exp -> . ( exp )
    (93) exp -> . ID
    (94) exp -> . literal
    (95) exp -> . ID [ exp ]
    (60) call_stmt -> . ID ( exp comma_exp_list )
    (61) call_stmt -> . vartype ( exp )
    (62) call_stmt -> . ID ( )
    (70) literal -> . LITERAL_INT
    (71) literal -> . LITERAL_REAL
    (72) literal -> . LITERAL_BOOL
    (73) literal -> . LITERAL_CHAR
    (74) literal -> . LITERAL_STRING
    (27) vartype -> . INT
    (28) vartype -> . REAL
    (29) vartype -> . BOOL
    (30) vartype -> . CHAR
    (31) vartype -> . STRING
    (32) vartype -> . ARRAY [ LITERAL_INT ] OF vartype
    (33) vartype -> . ARRAY [ LITERAL_INT RANGE LITERAL_INT ] OF vartype

    NOT             shift and go to state 67
    -               shift and go to state 66
    +               shift and go to state 65
    (               shift and go to state 68
    ID              shift and go to state 69
    LITERAL_INT     shift and go to state 71
    LITERAL_REAL    shift and go to state 72
    LITERAL_BOOL    shift and go to state 73
    LITERAL_CHAR    shift and go to state 74
    LITERAL_STRING  shift and go to state 75
    INT             shift and go to state 38
    REAL            shift and go to state 39
    BOOL            shift and go to state 40
    CHAR            shift and go to state 41
    STRING          shift and go to state 42
    ARRAY           shift and go to state 43

    exp                            shift and go to state 63
    call_stmt                      shift and go to state 64
    literal                        shift and go to state 70
    vartype                        shift and go to state 31

state 34

    (51) while_stmt -> WHILE . exp DO stmt
    (75) exp -> . call_stmt
    (76) exp -> . exp + exp
    (77) exp -> . exp - exp
    (78) exp -> . exp * exp
    (79) exp -> . exp / exp
    (80) exp -> . exp % exp
    (81) exp -> . exp EQ exp
    (82) exp -> . exp NEQ exp
    (83) exp -> . exp LT exp
    (84) exp -> . exp GT exp
    (85) exp -> . exp LEQ exp
    (86) exp -> . exp GEQ exp
    (87) exp -> . exp AND exp
    (88) exp -> . exp OR exp
    (89) exp -> . NOT exp
    (90) exp -> . - exp
    (91) exp -> . + exp
    (92) exp -> . ( exp )
    (93) exp -> . ID
    (94) exp -> . literal
    (95) exp -> . ID [ exp ]
    (60) call_stmt -> . ID ( exp comma_exp_list )
    (61) call_stmt -> . vartype ( exp )
    (62) call_stmt -> . ID ( )
    (70) literal -> . LITERAL_INT
    (71) literal -> . LITERAL_REAL
    (72) literal -> . LITERAL_BOOL
    (73) literal -> . LITERAL_CHAR
    (74) literal -> . LITERAL_STRING
    (27) vartype -> . INT
    (28) vartype -> . REAL
    (29) vartype -> . BOOL
    (30) vartype -> . CHAR
    (31) vartype -> . STRING
    (32) vartype -> . ARRAY [ LITERAL_INT ] OF vartype
    (33) vartype -> . ARRAY [ LITERAL_INT RANGE LITERAL_INT ] OF vartype

    NOT             shift and go to state 67
    -               shift and go to state 66
    +               shift and go to state 65
    (               shift and go to state 68
    ID              shift and go to state 69
    LITERAL_INT     shift and go to state 71
    LITERAL_REAL    shift and go to state 72
    LITERAL_BOOL    shift and go to state 73
    LITERAL_CHAR    shift and go to state 74
    LITERAL_STRING  shift and go to state 75
    INT             shift and go to state 38
    REAL            shift and go to state 39
    BOOL            shift and go to state 40
    CHAR            shift and go to state 41
    STRING          shift and go to state 42
    ARRAY           shift and go to state 43

    exp                            shift and go to state 76
    call_stmt                      shift and go to state 64
    literal                        shift and go to state 70
    vartype                        shift and go to state 31

state 35

    (52) repeat_stmt -> REPEAT . stmt semicolon_stmt_list UNTIL exp
    (36) stmt -> . ID : non_label_stmt
    (37) stmt -> . non_label_stmt
    (38) non_label_stmt -> . assign_stmt
    (39) non_label_stmt -> . call_stmt
    (40) non_label_stmt -> . for_stmt
    (41) non_label_stmt -> . if_stmt
    (42) non_label_stmt -> . while_stmt
    (43) non_label_stmt -> . repeat_stmt
    (44) non_label_stmt -> . case_stmt
    (45) non_label_stmt -> . goto_stmt
    (46) non_label_stmt -> . compound_stmt
    (47) assign_stmt -> . lvalue ASSIGN exp
    (60) call_stmt -> . ID ( exp comma_exp_list )
    (61) call_stmt -> . vartype ( exp )
    (62) call_stmt -> . ID ( )
    (48) for_stmt -> . FOR ID ASSIGN exp direction exp DO stmt
    (65) if_stmt -> . IF exp THEN stmt else_stmt
    (51) while_stmt -> . WHILE exp DO stmt
    (52) repeat_stmt -> . REPEAT stmt semicolon_stmt_list UNTIL exp
    (53) case_stmt -> . CASE exp OF case_exp_list END
    (58) goto_stmt -> . GOTO ID
    (59) compound_stmt -> . BEGIN stmt semicolon_stmt_list END
    (68) lvalue -> . ID
    (69) lvalue -> . ID [ exp ]
    (27) vartype -> . INT
    (28) vartype -> . REAL
    (29) vartype -> . BOOL
    (30) vartype -> . CHAR
    (31) vartype -> . STRING
    (32) vartype -> . ARRAY [ LITERAL_INT ] OF vartype
    (33) vartype -> . ARRAY [ LITERAL_INT RANGE LITERAL_INT ] OF vartype

    ID              shift and go to state 19
    FOR             shift and go to state 32
    IF              shift and go to state 33
    WHILE           shift and go to state 34
    REPEAT          shift and go to state 35
    CASE            shift and go to state 36
    GOTO            shift and go to state 37
    BEGIN           shift and go to state 11
    INT             shift and go to state 38
    REAL            shift and go to state 39
    BOOL            shift and go to state 40
    CHAR            shift and go to state 41
    STRING          shift and go to state 42
    ARRAY           shift and go to state 43

    stmt                           shift and go to state 77
    non_label_stmt                 shift and go to state 20
    assign_stmt                    shift and go to state 21
    call_stmt                      shift and go to state 22
    for_stmt                       shift and go to state 23
    if_stmt                        shift and go to state 24
    while_stmt                     shift and go to state 25
    repeat_stmt                    shift and go to state 26
    case_stmt                      shift and go to state 27
    goto_stmt                      shift and go to state 28
    compound_stmt                  shift and go to state 29
    lvalue                         shift and go to state 30
    vartype                        shift and go to state 31

state 36

    (53) case_stmt -> CASE . exp OF case_exp_list END
    (75) exp -> . call_stmt
    (76) exp -> . exp + exp
    (77) exp -> . exp - exp
    (78) exp -> . exp * exp
    (79) exp -> . exp / exp
    (80) exp -> . exp % exp
    (81) exp -> . exp EQ exp
    (82) exp -> . exp NEQ exp
    (83) exp -> . exp LT exp
    (84) exp -> . exp GT exp
    (85) exp -> . exp LEQ exp
    (86) exp -> . exp GEQ exp
    (87) exp -> . exp AND exp
    (88) exp -> . exp OR exp
    (89) exp -> . NOT exp
    (90) exp -> . - exp
    (91) exp -> . + exp
    (92) exp -> . ( exp )
    (93) exp -> . ID
    (94) exp -> . literal
    (95) exp -> . ID [ exp ]
    (60) call_stmt -> . ID ( exp comma_exp_list )
    (61) call_stmt -> . vartype ( exp )
    (62) call_stmt -> . ID ( )
    (70) literal -> . LITERAL_INT
    (71) literal -> . LITERAL_REAL
    (72) literal -> . LITERAL_BOOL
    (73) literal -> . LITERAL_CHAR
    (74) literal -> . LITERAL_STRING
    (27) vartype -> . INT
    (28) vartype -> . REAL
    (29) vartype -> . BOOL
    (30) vartype -> . CHAR
    (31) vartype -> . STRING
    (32) vartype -> . ARRAY [ LITERAL_INT ] OF vartype
    (33) vartype -> . ARRAY [ LITERAL_INT RANGE LITERAL_INT ] OF vartype

    NOT             shift and go to state 67
    -               shift and go to state 66
    +               shift and go to state 65
    (               shift and go to state 68
    ID              shift and go to state 69
    LITERAL_INT     shift and go to state 71
    LITERAL_REAL    shift and go to state 72
    LITERAL_BOOL    shift and go to state 73
    LITERAL_CHAR    shift and go to state 74
    LITERAL_STRING  shift and go to state 75
    INT             shift and go to state 38
    REAL            shift and go to state 39
    BOOL            shift and go to state 40
    CHAR            shift and go to state 41
    STRING          shift and go to state 42
    ARRAY           shift and go to state 43

    exp                            shift and go to state 78
    call_stmt                      shift and go to state 64
    literal                        shift and go to state 70
    vartype                        shift and go to state 31

state 37

    (58) goto_stmt -> GOTO . ID

    ID              shift and go to state 79


state 38

    (27) vartype -> INT .

    (               reduce using rule 27 (vartype -> INT .)
    ;               reduce using rule 27 (vartype -> INT .)
    EQ              reduce using rule 27 (vartype -> INT .)
    )               reduce using rule 27 (vartype -> INT .)


state 39

    (28) vartype -> REAL .

    (               reduce using rule 28 (vartype -> REAL .)
    ;               reduce using rule 28 (vartype -> REAL .)
    EQ              reduce using rule 28 (vartype -> REAL .)
    )               reduce using rule 28 (vartype -> REAL .)


state 40

    (29) vartype -> BOOL .

    (               reduce using rule 29 (vartype -> BOOL .)
    ;               reduce using rule 29 (vartype -> BOOL .)
    EQ              reduce using rule 29 (vartype -> BOOL .)
    )               reduce using rule 29 (vartype -> BOOL .)


state 41

    (30) vartype -> CHAR .

    (               reduce using rule 30 (vartype -> CHAR .)
    ;               reduce using rule 30 (vartype -> CHAR .)
    EQ              reduce using rule 30 (vartype -> CHAR .)
    )               reduce using rule 30 (vartype -> CHAR .)


state 42

    (31) vartype -> STRING .

    (               reduce using rule 31 (vartype -> STRING .)
    ;               reduce using rule 31 (vartype -> STRING .)
    EQ              reduce using rule 31 (vartype -> STRING .)
    )               reduce using rule 31 (vartype -> STRING .)


state 43

    (32) vartype -> ARRAY . [ LITERAL_INT ] OF vartype
    (33) vartype -> ARRAY . [ LITERAL_INT RANGE LITERAL_INT ] OF vartype

    [               shift and go to state 80


state 44

    (5) local -> VAR var_list .
    (9) var_list -> var_list . var
    (11) var -> . id_list : vartype ;
    (12) var -> . id_list : vartype EQ exp ;
    (16) id_list -> . ID comma_id_list

    BEGIN           reduce using rule 5 (local -> VAR var_list .)
    VAR             reduce using rule 5 (local -> VAR var_list .)
    LABEL           reduce using rule 5 (local -> VAR var_list .)
    CONST           reduce using rule 5 (local -> VAR var_list .)
    PROCEDURE       reduce using rule 5 (local -> VAR var_list .)
    FUNCTION        reduce using rule 5 (local -> VAR var_list .)
    ID              shift and go to state 47

    var                            shift and go to state 81
    id_list                        shift and go to state 46

state 45

    (10) var_list -> var .

    ID              reduce using rule 10 (var_list -> var .)
    BEGIN           reduce using rule 10 (var_list -> var .)
    VAR             reduce using rule 10 (var_list -> var .)
    LABEL           reduce using rule 10 (var_list -> var .)
    CONST           reduce using rule 10 (var_list -> var .)
    PROCEDURE       reduce using rule 10 (var_list -> var .)
    FUNCTION        reduce using rule 10 (var_list -> var .)


state 46

    (11) var -> id_list . : vartype ;
    (12) var -> id_list . : vartype EQ exp ;

    :               shift and go to state 82


state 47

    (16) id_list -> ID . comma_id_list
    (17) comma_id_list -> . comma_id_list , ID
    (18) comma_id_list -> . empty
    (96) empty -> .

    ,               reduce using rule 96 (empty -> .)
    :               reduce using rule 96 (empty -> .)
    ;               reduce using rule 96 (empty -> .)
    EQ              reduce using rule 96 (empty -> .)

    comma_id_list                  shift and go to state 83
    empty                          shift and go to state 84

state 48

    (6) local -> LABEL id_list . ;

    ;               shift and go to state 85


state 49

    (7) local -> CONST const_exp_list .
    (13) const_exp_list -> const_exp_list . const_exp
    (15) const_exp -> . id_list EQ literal ;
    (16) id_list -> . ID comma_id_list

    BEGIN           reduce using rule 7 (local -> CONST const_exp_list .)
    VAR             reduce using rule 7 (local -> CONST const_exp_list .)
    LABEL           reduce using rule 7 (local -> CONST const_exp_list .)
    CONST           reduce using rule 7 (local -> CONST const_exp_list .)
    PROCEDURE       reduce using rule 7 (local -> CONST const_exp_list .)
    FUNCTION        reduce using rule 7 (local -> CONST const_exp_list .)
    ID              shift and go to state 47

    const_exp                      shift and go to state 86
    id_list                        shift and go to state 51

state 50

    (14) const_exp_list -> const_exp .

    ID              reduce using rule 14 (const_exp_list -> const_exp .)
    BEGIN           reduce using rule 14 (const_exp_list -> const_exp .)
    VAR             reduce using rule 14 (const_exp_list -> const_exp .)
    LABEL           reduce using rule 14 (const_exp_list -> const_exp .)
    CONST           reduce using rule 14 (const_exp_list -> const_exp .)
    PROCEDURE       reduce using rule 14 (const_exp_list -> const_exp .)
    FUNCTION        reduce using rule 14 (const_exp_list -> const_exp .)


state 51

    (15) const_exp -> id_list . EQ literal ;

    EQ              shift and go to state 87


state 52

    (8) local -> header ; . body ;
    (2) body -> . local_list compound_stmt
    (3) local_list -> . local_list local
    (4) local_list -> . empty
    (96) empty -> .

    BEGIN           reduce using rule 96 (empty -> .)
    VAR             reduce using rule 96 (empty -> .)
    LABEL           reduce using rule 96 (empty -> .)
    CONST           reduce using rule 96 (empty -> .)
    PROCEDURE       reduce using rule 96 (empty -> .)
    FUNCTION        reduce using rule 96 (empty -> .)

    body                           shift and go to state 88
    local_list                     shift and go to state 6
    empty                          shift and go to state 7

state 53

    (19) header -> PROCEDURE ID . ( formal_list )
    (20) header -> PROCEDURE ID . ( )

    (               shift and go to state 89


state 54

    (21) header -> FUNCTION ID . ( formal_list ) : vartype
    (22) header -> FUNCTION ID . ( ) : vartype

    (               shift and go to state 90


state 55

    (59) compound_stmt -> BEGIN stmt semicolon_stmt_list . END
    (34) semicolon_stmt_list -> semicolon_stmt_list . ; stmt

    END             shift and go to state 91
    ;               shift and go to state 92


state 56

    (35) semicolon_stmt_list -> empty .

    END             reduce using rule 35 (semicolon_stmt_list -> empty .)
    ;               reduce using rule 35 (semicolon_stmt_list -> empty .)
    UNTIL           reduce using rule 35 (semicolon_stmt_list -> empty .)


state 57

    (36) stmt -> ID : . non_label_stmt
    (38) non_label_stmt -> . assign_stmt
    (39) non_label_stmt -> . call_stmt
    (40) non_label_stmt -> . for_stmt
    (41) non_label_stmt -> . if_stmt
    (42) non_label_stmt -> . while_stmt
    (43) non_label_stmt -> . repeat_stmt
    (44) non_label_stmt -> . case_stmt
    (45) non_label_stmt -> . goto_stmt
    (46) non_label_stmt -> . compound_stmt
    (47) assign_stmt -> . lvalue ASSIGN exp
    (60) call_stmt -> . ID ( exp comma_exp_list )
    (61) call_stmt -> . vartype ( exp )
    (62) call_stmt -> . ID ( )
    (48) for_stmt -> . FOR ID ASSIGN exp direction exp DO stmt
    (65) if_stmt -> . IF exp THEN stmt else_stmt
    (51) while_stmt -> . WHILE exp DO stmt
    (52) repeat_stmt -> . REPEAT stmt semicolon_stmt_list UNTIL exp
    (53) case_stmt -> . CASE exp OF case_exp_list END
    (58) goto_stmt -> . GOTO ID
    (59) compound_stmt -> . BEGIN stmt semicolon_stmt_list END
    (68) lvalue -> . ID
    (69) lvalue -> . ID [ exp ]
    (27) vartype -> . INT
    (28) vartype -> . REAL
    (29) vartype -> . BOOL
    (30) vartype -> . CHAR
    (31) vartype -> . STRING
    (32) vartype -> . ARRAY [ LITERAL_INT ] OF vartype
    (33) vartype -> . ARRAY [ LITERAL_INT RANGE LITERAL_INT ] OF vartype

    ID              shift and go to state 93
    FOR             shift and go to state 32
    IF              shift and go to state 33
    WHILE           shift and go to state 34
    REPEAT          shift and go to state 35
    CASE            shift and go to state 36
    GOTO            shift and go to state 37
    BEGIN           shift and go to state 11
    INT             shift and go to state 38
    REAL            shift and go to state 39
    BOOL            shift and go to state 40
    CHAR            shift and go to state 41
    STRING          shift and go to state 42
    ARRAY           shift and go to state 43

    non_label_stmt                 shift and go to state 94
    assign_stmt                    shift and go to state 21
    call_stmt                      shift and go to state 22
    for_stmt                       shift and go to state 23
    if_stmt                        shift and go to state 24
    while_stmt                     shift and go to state 25
    repeat_stmt                    shift and go to state 26
    case_stmt                      shift and go to state 27
    goto_stmt                      shift and go to state 28
    compound_stmt                  shift and go to state 29
    lvalue                         shift and go to state 30
    vartype                        shift and go to state 31

state 58

    (60) call_stmt -> ID ( . exp comma_exp_list )
    (62) call_stmt -> ID ( . )
    (75) exp -> . call_stmt
    (76) exp -> . exp + exp
    (77) exp -> . exp - exp
    (78) exp -> . exp * exp
    (79) exp -> . exp / exp
    (80) exp -> . exp % exp
    (81) exp -> . exp EQ exp
    (82) exp -> . exp NEQ exp
    (83) exp -> . exp LT exp
    (84) exp -> . exp GT exp
    (85) exp -> . exp LEQ exp
    (86) exp -> . exp GEQ exp
    (87) exp -> . exp AND exp
    (88) exp -> . exp OR exp
    (89) exp -> . NOT exp
    (90) exp -> . - exp
    (91) exp -> . + exp
    (92) exp -> . ( exp )
    (93) exp -> . ID
    (94) exp -> . literal
    (95) exp -> . ID [ exp ]
    (60) call_stmt -> . ID ( exp comma_exp_list )
    (61) call_stmt -> . vartype ( exp )
    (62) call_stmt -> . ID ( )
    (70) literal -> . LITERAL_INT
    (71) literal -> . LITERAL_REAL
    (72) literal -> . LITERAL_BOOL
    (73) literal -> . LITERAL_CHAR
    (74) literal -> . LITERAL_STRING
    (27) vartype -> . INT
    (28) vartype -> . REAL
    (29) vartype -> . BOOL
    (30) vartype -> . CHAR
    (31) vartype -> . STRING
    (32) vartype -> . ARRAY [ LITERAL_INT ] OF vartype
    (33) vartype -> . ARRAY [ LITERAL_INT RANGE LITERAL_INT ] OF vartype

    )               shift and go to state 96
    NOT             shift and go to state 67
    -               shift and go to state 66
    +               shift and go to state 65
    (               shift and go to state 68
    ID              shift and go to state 69
    LITERAL_INT     shift and go to state 71
    LITERAL_REAL    shift and go to state 72
    LITERAL_BOOL    shift and go to state 73
    LITERAL_CHAR    shift and go to state 74
    LITERAL_STRING  shift and go to state 75
    INT             shift and go to state 38
    REAL            shift and go to state 39
    BOOL            shift and go to state 40
    CHAR            shift and go to state 41
    STRING          shift and go to state 42
    ARRAY           shift and go to state 43

    exp                            shift and go to state 95
    call_stmt                      shift and go to state 64
    literal                        shift and go to state 70
    vartype                        shift and go to state 31

state 59

    (69) lvalue -> ID [ . exp ]
    (75) exp -> . call_stmt
    (76) exp -> . exp + exp
    (77) exp -> . exp - exp
    (78) exp -> . exp * exp
    (79) exp -> . exp / exp
    (80) exp -> . exp % exp
    (81) exp -> . exp EQ exp
    (82) exp -> . exp NEQ exp
    (83) exp -> . exp LT exp
    (84) exp -> . exp GT exp
    (85) exp -> . exp LEQ exp
    (86) exp -> . exp GEQ exp
    (87) exp -> . exp AND exp
    (88) exp -> . exp OR exp
    (89) exp -> . NOT exp
    (90) exp -> . - exp
    (91) exp -> . + exp
    (92) exp -> . ( exp )
    (93) exp -> . ID
    (94) exp -> . literal
    (95) exp -> . ID [ exp ]
    (60) call_stmt -> . ID ( exp comma_exp_list )
    (61) call_stmt -> . vartype ( exp )
    (62) call_stmt -> . ID ( )
    (70) literal -> . LITERAL_INT
    (71) literal -> . LITERAL_REAL
    (72) literal -> . LITERAL_BOOL
    (73) literal -> . LITERAL_CHAR
    (74) literal -> . LITERAL_STRING
    (27) vartype -> . INT
    (28) vartype -> . REAL
    (29) vartype -> . BOOL
    (30) vartype -> . CHAR
    (31) vartype -> . STRING
    (32) vartype -> . ARRAY [ LITERAL_INT ] OF vartype
    (33) vartype -> . ARRAY [ LITERAL_INT RANGE LITERAL_INT ] OF vartype

    NOT             shift and go to state 67
    -               shift and go to state 66
    +               shift and go to state 65
    (               shift and go to state 68
    ID              shift and go to state 69
    LITERAL_INT     shift and go to state 71
    LITERAL_REAL    shift and go to state 72
    LITERAL_BOOL    shift and go to state 73
    LITERAL_CHAR    shift and go to state 74
    LITERAL_STRING  shift and go to state 75
    INT             shift and go to state 38
    REAL            shift and go to state 39
    BOOL            shift and go to state 40
    CHAR            shift and go to state 41
    STRING          shift and go to state 42
    ARRAY           shift and go to state 43

    exp                            shift and go to state 97
    call_stmt                      shift and go to state 64
    literal                        shift and go to state 70
    vartype                        shift and go to state 31

state 60

    (47) assign_stmt -> lvalue ASSIGN . exp
    (75) exp -> . call_stmt
    (76) exp -> . exp + exp
    (77) exp -> . exp - exp
    (78) exp -> . exp * exp
    (79) exp -> . exp / exp
    (80) exp -> . exp % exp
    (81) exp -> . exp EQ exp
    (82) exp -> . exp NEQ exp
    (83) exp -> . exp LT exp
    (84) exp -> . exp GT exp
    (85) exp -> . exp LEQ exp
    (86) exp -> . exp GEQ exp
    (87) exp -> . exp AND exp
    (88) exp -> . exp OR exp
    (89) exp -> . NOT exp
    (90) exp -> . - exp
    (91) exp -> . + exp
    (92) exp -> . ( exp )
    (93) exp -> . ID
    (94) exp -> . literal
    (95) exp -> . ID [ exp ]
    (60) call_stmt -> . ID ( exp comma_exp_list )
    (61) call_stmt -> . vartype ( exp )
    (62) call_stmt -> . ID ( )
    (70) literal -> . LITERAL_INT
    (71) literal -> . LITERAL_REAL
    (72) literal -> . LITERAL_BOOL
    (73) literal -> . LITERAL_CHAR
    (74) literal -> . LITERAL_STRING
    (27) vartype -> . INT
    (28) vartype -> . REAL
    (29) vartype -> . BOOL
    (30) vartype -> . CHAR
    (31) vartype -> . STRING
    (32) vartype -> . ARRAY [ LITERAL_INT ] OF vartype
    (33) vartype -> . ARRAY [ LITERAL_INT RANGE LITERAL_INT ] OF vartype

    NOT             shift and go to state 67
    -               shift and go to state 66
    +               shift and go to state 65
    (               shift and go to state 68
    ID              shift and go to state 69
    LITERAL_INT     shift and go to state 71
    LITERAL_REAL    shift and go to state 72
    LITERAL_BOOL    shift and go to state 73
    LITERAL_CHAR    shift and go to state 74
    LITERAL_STRING  shift and go to state 75
    INT             shift and go to state 38
    REAL            shift and go to state 39
    BOOL            shift and go to state 40
    CHAR            shift and go to state 41
    STRING          shift and go to state 42
    ARRAY           shift and go to state 43

    exp                            shift and go to state 98
    call_stmt                      shift and go to state 64
    literal                        shift and go to state 70
    vartype                        shift and go to state 31

state 61

    (61) call_stmt -> vartype ( . exp )
    (75) exp -> . call_stmt
    (76) exp -> . exp + exp
    (77) exp -> . exp - exp
    (78) exp -> . exp * exp
    (79) exp -> . exp / exp
    (80) exp -> . exp % exp
    (81) exp -> . exp EQ exp
    (82) exp -> . exp NEQ exp
    (83) exp -> . exp LT exp
    (84) exp -> . exp GT exp
    (85) exp -> . exp LEQ exp
    (86) exp -> . exp GEQ exp
    (87) exp -> . exp AND exp
    (88) exp -> . exp OR exp
    (89) exp -> . NOT exp
    (90) exp -> . - exp
    (91) exp -> . + exp
    (92) exp -> . ( exp )
    (93) exp -> . ID
    (94) exp -> . literal
    (95) exp -> . ID [ exp ]
    (60) call_stmt -> . ID ( exp comma_exp_list )
    (61) call_stmt -> . vartype ( exp )
    (62) call_stmt -> . ID ( )
    (70) literal -> . LITERAL_INT
    (71) literal -> . LITERAL_REAL
    (72) literal -> . LITERAL_BOOL
    (73) literal -> . LITERAL_CHAR
    (74) literal -> . LITERAL_STRING
    (27) vartype -> . INT
    (28) vartype -> . REAL
    (29) vartype -> . BOOL
    (30) vartype -> . CHAR
    (31) vartype -> . STRING
    (32) vartype -> . ARRAY [ LITERAL_INT ] OF vartype
    (33) vartype -> . ARRAY [ LITERAL_INT RANGE LITERAL_INT ] OF vartype

    NOT             shift and go to state 67
    -               shift and go to state 66
    +               shift and go to state 65
    (               shift and go to state 68
    ID              shift and go to state 69
    LITERAL_INT     shift and go to state 71
    LITERAL_REAL    shift and go to state 72
    LITERAL_BOOL    shift and go to state 73
    LITERAL_CHAR    shift and go to state 74
    LITERAL_STRING  shift and go to state 75
    INT             shift and go to state 38
    REAL            shift and go to state 39
    BOOL            shift and go to state 40
    CHAR            shift and go to state 41
    STRING          shift and go to state 42
    ARRAY           shift and go to state 43

    vartype                        shift and go to state 31
    exp                            shift and go to state 99
    call_stmt                      shift and go to state 64
    literal                        shift and go to state 70

state 62

    (48) for_stmt -> FOR ID . ASSIGN exp direction exp DO stmt

    ASSIGN          shift and go to state 100


state 63

    (65) if_stmt -> IF exp . THEN stmt else_stmt
    (76) exp -> exp . + exp
    (77) exp -> exp . - exp
    (78) exp -> exp . * exp
    (79) exp -> exp . / exp
    (80) exp -> exp . % exp
    (81) exp -> exp . EQ exp
    (82) exp -> exp . NEQ exp
    (83) exp -> exp . LT exp
    (84) exp -> exp . GT exp
    (85) exp -> exp . LEQ exp
    (86) exp -> exp . GEQ exp
    (87) exp -> exp . AND exp
    (88) exp -> exp . OR exp

    THEN            shift and go to state 101
    +               shift and go to state 102
    -               shift and go to state 103
    *               shift and go to state 104
    /               shift and go to state 105
    %               shift and go to state 106
    EQ              shift and go to state 107
    NEQ             shift and go to state 108
    LT              shift and go to state 109
    GT              shift and go to state 110
    LEQ             shift and go to state 111
    GEQ             shift and go to state 112
    AND             shift and go to state 113
    OR              shift and go to state 114


state 64

    (75) exp -> call_stmt .

    THEN            reduce using rule 75 (exp -> call_stmt .)
    +               reduce using rule 75 (exp -> call_stmt .)
    -               reduce using rule 75 (exp -> call_stmt .)
    *               reduce using rule 75 (exp -> call_stmt .)
    /               reduce using rule 75 (exp -> call_stmt .)
    %               reduce using rule 75 (exp -> call_stmt .)
    EQ              reduce using rule 75 (exp -> call_stmt .)
    NEQ             reduce using rule 75 (exp -> call_stmt .)
    LT              reduce using rule 75 (exp -> call_stmt .)
    GT              reduce using rule 75 (exp -> call_stmt .)
    LEQ             reduce using rule 75 (exp -> call_stmt .)
    GEQ             reduce using rule 75 (exp -> call_stmt .)
    AND             reduce using rule 75 (exp -> call_stmt .)
    OR              reduce using rule 75 (exp -> call_stmt .)
    DO              reduce using rule 75 (exp -> call_stmt .)
    OF              reduce using rule 75 (exp -> call_stmt .)
    )               reduce using rule 75 (exp -> call_stmt .)
    ,               reduce using rule 75 (exp -> call_stmt .)
    ]               reduce using rule 75 (exp -> call_stmt .)
    END             reduce using rule 75 (exp -> call_stmt .)
    ;               reduce using rule 75 (exp -> call_stmt .)
    UNTIL           reduce using rule 75 (exp -> call_stmt .)
    ELSE            reduce using rule 75 (exp -> call_stmt .)
    DOWNTO          reduce using rule 75 (exp -> call_stmt .)
    TO              reduce using rule 75 (exp -> call_stmt .)


state 65

    (91) exp -> + . exp
    (75) exp -> . call_stmt
    (76) exp -> . exp + exp
    (77) exp -> . exp - exp
    (78) exp -> . exp * exp
    (79) exp -> . exp / exp
    (80) exp -> . exp % exp
    (81) exp -> . exp EQ exp
    (82) exp -> . exp NEQ exp
    (83) exp -> . exp LT exp
    (84) exp -> . exp GT exp
    (85) exp -> . exp LEQ exp
    (86) exp -> . exp GEQ exp
    (87) exp -> . exp AND exp
    (88) exp -> . exp OR exp
    (89) exp -> . NOT exp
    (90) exp -> . - exp
    (91) exp -> . + exp
    (92) exp -> . ( exp )
    (93) exp -> . ID
    (94) exp -> . literal
    (95) exp -> . ID [ exp ]
    (60) call_stmt -> . ID ( exp comma_exp_list )
    (61) call_stmt -> . vartype ( exp )
    (62) call_stmt -> . ID ( )
    (70) literal -> . LITERAL_INT
    (71) literal -> . LITERAL_REAL
    (72) literal -> . LITERAL_BOOL
    (73) literal -> . LITERAL_CHAR
    (74) literal -> . LITERAL_STRING
    (27) vartype -> . INT
    (28) vartype -> . REAL
    (29) vartype -> . BOOL
    (30) vartype -> . CHAR
    (31) vartype -> . STRING
    (32) vartype -> . ARRAY [ LITERAL_INT ] OF vartype
    (33) vartype -> . ARRAY [ LITERAL_INT RANGE LITERAL_INT ] OF vartype

    NOT             shift and go to state 67
    -               shift and go to state 66
    +               shift and go to state 65
    (               shift and go to state 68
    ID              shift and go to state 69
    LITERAL_INT     shift and go to state 71
    LITERAL_REAL    shift and go to state 72
    LITERAL_BOOL    shift and go to state 73
    LITERAL_CHAR    shift and go to state 74
    LITERAL_STRING  shift and go to state 75
    INT             shift and go to state 38
    REAL            shift and go to state 39
    BOOL            shift and go to state 40
    CHAR            shift and go to state 41
    STRING          shift and go to state 42
    ARRAY           shift and go to state 43

    exp                            shift and go to state 115
    call_stmt                      shift and go to state 64
    literal                        shift and go to state 70
    vartype                        shift and go to state 31

state 66

    (90) exp -> - . exp
    (75) exp -> . call_stmt
    (76) exp -> . exp + exp
    (77) exp -> . exp - exp
    (78) exp -> . exp * exp
    (79) exp -> . exp / exp
    (80) exp -> . exp % exp
    (81) exp -> . exp EQ exp
    (82) exp -> . exp NEQ exp
    (83) exp -> . exp LT exp
    (84) exp -> . exp GT exp
    (85) exp -> . exp LEQ exp
    (86) exp -> . exp GEQ exp
    (87) exp -> . exp AND exp
    (88) exp -> . exp OR exp
    (89) exp -> . NOT exp
    (90) exp -> . - exp
    (91) exp -> . + exp
    (92) exp -> . ( exp )
    (93) exp -> . ID
    (94) exp -> . literal
    (95) exp -> . ID [ exp ]
    (60) call_stmt -> . ID ( exp comma_exp_list )
    (61) call_stmt -> . vartype ( exp )
    (62) call_stmt -> . ID ( )
    (70) literal -> . LITERAL_INT
    (71) literal -> . LITERAL_REAL
    (72) literal -> . LITERAL_BOOL
    (73) literal -> . LITERAL_CHAR
    (74) literal -> . LITERAL_STRING
    (27) vartype -> . INT
    (28) vartype -> . REAL
    (29) vartype -> . BOOL
    (30) vartype -> . CHAR
    (31) vartype -> . STRING
    (32) vartype -> . ARRAY [ LITERAL_INT ] OF vartype
    (33) vartype -> . ARRAY [ LITERAL_INT RANGE LITERAL_INT ] OF vartype

    NOT             shift and go to state 67
    -               shift and go to state 66
    +               shift and go to state 65
    (               shift and go to state 68
    ID              shift and go to state 69
    LITERAL_INT     shift and go to state 71
    LITERAL_REAL    shift and go to state 72
    LITERAL_BOOL    shift and go to state 73
    LITERAL_CHAR    shift and go to state 74
    LITERAL_STRING  shift and go to state 75
    INT             shift and go to state 38
    REAL            shift and go to state 39
    BOOL            shift and go to state 40
    CHAR            shift and go to state 41
    STRING          shift and go to state 42
    ARRAY           shift and go to state 43

    exp                            shift and go to state 116
    call_stmt                      shift and go to state 64
    literal                        shift and go to state 70
    vartype                        shift and go to state 31

state 67

    (89) exp -> NOT . exp
    (75) exp -> . call_stmt
    (76) exp -> . exp + exp
    (77) exp -> . exp - exp
    (78) exp -> . exp * exp
    (79) exp -> . exp / exp
    (80) exp -> . exp % exp
    (81) exp -> . exp EQ exp
    (82) exp -> . exp NEQ exp
    (83) exp -> . exp LT exp
    (84) exp -> . exp GT exp
    (85) exp -> . exp LEQ exp
    (86) exp -> . exp GEQ exp
    (87) exp -> . exp AND exp
    (88) exp -> . exp OR exp
    (89) exp -> . NOT exp
    (90) exp -> . - exp
    (91) exp -> . + exp
    (92) exp -> . ( exp )
    (93) exp -> . ID
    (94) exp -> . literal
    (95) exp -> . ID [ exp ]
    (60) call_stmt -> . ID ( exp comma_exp_list )
    (61) call_stmt -> . vartype ( exp )
    (62) call_stmt -> . ID ( )
    (70) literal -> . LITERAL_INT
    (71) literal -> . LITERAL_REAL
    (72) literal -> . LITERAL_BOOL
    (73) literal -> . LITERAL_CHAR
    (74) literal -> . LITERAL_STRING
    (27) vartype -> . INT
    (28) vartype -> . REAL
    (29) vartype -> . BOOL
    (30) vartype -> . CHAR
    (31) vartype -> . STRING
    (32) vartype -> . ARRAY [ LITERAL_INT ] OF vartype
    (33) vartype -> . ARRAY [ LITERAL_INT RANGE LITERAL_INT ] OF vartype

    NOT             shift and go to state 67
    -               shift and go to state 66
    +               shift and go to state 65
    (               shift and go to state 68
    ID              shift and go to state 69
    LITERAL_INT     shift and go to state 71
    LITERAL_REAL    shift and go to state 72
    LITERAL_BOOL    shift and go to state 73
    LITERAL_CHAR    shift and go to state 74
    LITERAL_STRING  shift and go to state 75
    INT             shift and go to state 38
    REAL            shift and go to state 39
    BOOL            shift and go to state 40
    CHAR            shift and go to state 41
    STRING          shift and go to state 42
    ARRAY           shift and go to state 43

    exp                            shift and go to state 117
    call_stmt                      shift and go to state 64
    literal                        shift and go to state 70
    vartype                        shift and go to state 31

state 68

    (92) exp -> ( . exp )
    (75) exp -> . call_stmt
    (76) exp -> . exp + exp
    (77) exp -> . exp - exp
    (78) exp -> . exp * exp
    (79) exp -> . exp / exp
    (80) exp -> . exp % exp
    (81) exp -> . exp EQ exp
    (82) exp -> . exp NEQ exp
    (83) exp -> . exp LT exp
    (84) exp -> . exp GT exp
    (85) exp -> . exp LEQ exp
    (86) exp -> . exp GEQ exp
    (87) exp -> . exp AND exp
    (88) exp -> . exp OR exp
    (89) exp -> . NOT exp
    (90) exp -> . - exp
    (91) exp -> . + exp
    (92) exp -> . ( exp )
    (93) exp -> . ID
    (94) exp -> . literal
    (95) exp -> . ID [ exp ]
    (60) call_stmt -> . ID ( exp comma_exp_list )
    (61) call_stmt -> . vartype ( exp )
    (62) call_stmt -> . ID ( )
    (70) literal -> . LITERAL_INT
    (71) literal -> . LITERAL_REAL
    (72) literal -> . LITERAL_BOOL
    (73) literal -> . LITERAL_CHAR
    (74) literal -> . LITERAL_STRING
    (27) vartype -> . INT
    (28) vartype -> . REAL
    (29) vartype -> . BOOL
    (30) vartype -> . CHAR
    (31) vartype -> . STRING
    (32) vartype -> . ARRAY [ LITERAL_INT ] OF vartype
    (33) vartype -> . ARRAY [ LITERAL_INT RANGE LITERAL_INT ] OF vartype

    NOT             shift and go to state 67
    -               shift and go to state 66
    +               shift and go to state 65
    (               shift and go to state 68
    ID              shift and go to state 69
    LITERAL_INT     shift and go to state 71
    LITERAL_REAL    shift and go to state 72
    LITERAL_BOOL    shift and go to state 73
    LITERAL_CHAR    shift and go to state 74
    LITERAL_STRING  shift and go to state 75
    INT             shift and go to state 38
    REAL            shift and go to state 39
    BOOL            shift and go to state 40
    CHAR            shift and go to state 41
    STRING          shift and go to state 42
    ARRAY           shift and go to state 43

    exp                            shift and go to state 118
    call_stmt                      shift and go to state 64
    literal                        shift and go to state 70
    vartype                        shift and go to state 31

state 69

    (93) exp -> ID .
    (95) exp -> ID . [ exp ]
    (60) call_stmt -> ID . ( exp comma_exp_list )
    (62) call_stmt -> ID . ( )

    THEN            reduce using rule 93 (exp -> ID .)
    +               reduce using rule 93 (exp -> ID .)
    -               reduce using rule 93 (exp -> ID .)
    *               reduce using rule 93 (exp -> ID .)
    /               reduce using rule 93 (exp -> ID .)
    %               reduce using rule 93 (exp -> ID .)
    EQ              reduce using rule 93 (exp -> ID .)
    NEQ             reduce using rule 93 (exp -> ID .)
    LT              reduce using rule 93 (exp -> ID .)
    GT              reduce using rule 93 (exp -> ID .)
    LEQ             reduce using rule 93 (exp -> ID .)
    GEQ             reduce using rule 93 (exp -> ID .)
    AND             reduce using rule 93 (exp -> ID .)
    OR              reduce using rule 93 (exp -> ID .)
    DO              reduce using rule 93 (exp -> ID .)
    OF              reduce using rule 93 (exp -> ID .)
    )               reduce using rule 93 (exp -> ID .)
    ,               reduce using rule 93 (exp -> ID .)
    ]               reduce using rule 93 (exp -> ID .)
    END             reduce using rule 93 (exp -> ID .)
    ;               reduce using rule 93 (exp -> ID .)
    UNTIL           reduce using rule 93 (exp -> ID .)
    ELSE            reduce using rule 93 (exp -> ID .)
    DOWNTO          reduce using rule 93 (exp -> ID .)
    TO              reduce using rule 93 (exp -> ID .)
    [               shift and go to state 119
    (               shift and go to state 58


state 70

    (94) exp -> literal .

    THEN            reduce using rule 94 (exp -> literal .)
    +               reduce using rule 94 (exp -> literal .)
    -               reduce using rule 94 (exp -> literal .)
    *               reduce using rule 94 (exp -> literal .)
    /               reduce using rule 94 (exp -> literal .)
    %               reduce using rule 94 (exp -> literal .)
    EQ              reduce using rule 94 (exp -> literal .)
    NEQ             reduce using rule 94 (exp -> literal .)
    LT              reduce using rule 94 (exp -> literal .)
    GT              reduce using rule 94 (exp -> literal .)
    LEQ             reduce using rule 94 (exp -> literal .)
    GEQ             reduce using rule 94 (exp -> literal .)
    AND             reduce using rule 94 (exp -> literal .)
    OR              reduce using rule 94 (exp -> literal .)
    DO              reduce using rule 94 (exp -> literal .)
    OF              reduce using rule 94 (exp -> literal .)
    )               reduce using rule 94 (exp -> literal .)
    ,               reduce using rule 94 (exp -> literal .)
    ]               reduce using rule 94 (exp -> literal .)
    END             reduce using rule 94 (exp -> literal .)
    ;               reduce using rule 94 (exp -> literal .)
    UNTIL           reduce using rule 94 (exp -> literal .)
    ELSE            reduce using rule 94 (exp -> literal .)
    DOWNTO          reduce using rule 94 (exp -> literal .)
    TO              reduce using rule 94 (exp -> literal .)


state 71

    (70) literal -> LITERAL_INT .

    THEN            reduce using rule 70 (literal -> LITERAL_INT .)
    +               reduce using rule 70 (literal -> LITERAL_INT .)
    -               reduce using rule 70 (literal -> LITERAL_INT .)
    *               reduce using rule 70 (literal -> LITERAL_INT .)
    /               reduce using rule 70 (literal -> LITERAL_INT .)
    %               reduce using rule 70 (literal -> LITERAL_INT .)
    EQ              reduce using rule 70 (literal -> LITERAL_INT .)
    NEQ             reduce using rule 70 (literal -> LITERAL_INT .)
    LT              reduce using rule 70 (literal -> LITERAL_INT .)
    GT              reduce using rule 70 (literal -> LITERAL_INT .)
    LEQ             reduce using rule 70 (literal -> LITERAL_INT .)
    GEQ             reduce using rule 70 (literal -> LITERAL_INT .)
    AND             reduce using rule 70 (literal -> LITERAL_INT .)
    OR              reduce using rule 70 (literal -> LITERAL_INT .)
    DO              reduce using rule 70 (literal -> LITERAL_INT .)
    OF              reduce using rule 70 (literal -> LITERAL_INT .)
    )               reduce using rule 70 (literal -> LITERAL_INT .)
    ,               reduce using rule 70 (literal -> LITERAL_INT .)
    ]               reduce using rule 70 (literal -> LITERAL_INT .)
    END             reduce using rule 70 (literal -> LITERAL_INT .)
    ;               reduce using rule 70 (literal -> LITERAL_INT .)
    UNTIL           reduce using rule 70 (literal -> LITERAL_INT .)
    ELSE            reduce using rule 70 (literal -> LITERAL_INT .)
    DOWNTO          reduce using rule 70 (literal -> LITERAL_INT .)
    TO              reduce using rule 70 (literal -> LITERAL_INT .)
    :               reduce using rule 70 (literal -> LITERAL_INT .)


state 72

    (71) literal -> LITERAL_REAL .

    THEN            reduce using rule 71 (literal -> LITERAL_REAL .)
    +               reduce using rule 71 (literal -> LITERAL_REAL .)
    -               reduce using rule 71 (literal -> LITERAL_REAL .)
    *               reduce using rule 71 (literal -> LITERAL_REAL .)
    /               reduce using rule 71 (literal -> LITERAL_REAL .)
    %               reduce using rule 71 (literal -> LITERAL_REAL .)
    EQ              reduce using rule 71 (literal -> LITERAL_REAL .)
    NEQ             reduce using rule 71 (literal -> LITERAL_REAL .)
    LT              reduce using rule 71 (literal -> LITERAL_REAL .)
    GT              reduce using rule 71 (literal -> LITERAL_REAL .)
    LEQ             reduce using rule 71 (literal -> LITERAL_REAL .)
    GEQ             reduce using rule 71 (literal -> LITERAL_REAL .)
    AND             reduce using rule 71 (literal -> LITERAL_REAL .)
    OR              reduce using rule 71 (literal -> LITERAL_REAL .)
    DO              reduce using rule 71 (literal -> LITERAL_REAL .)
    OF              reduce using rule 71 (literal -> LITERAL_REAL .)
    )               reduce using rule 71 (literal -> LITERAL_REAL .)
    ,               reduce using rule 71 (literal -> LITERAL_REAL .)
    ]               reduce using rule 71 (literal -> LITERAL_REAL .)
    END             reduce using rule 71 (literal -> LITERAL_REAL .)
    ;               reduce using rule 71 (literal -> LITERAL_REAL .)
    UNTIL           reduce using rule 71 (literal -> LITERAL_REAL .)
    ELSE            reduce using rule 71 (literal -> LITERAL_REAL .)
    DOWNTO          reduce using rule 71 (literal -> LITERAL_REAL .)
    TO              reduce using rule 71 (literal -> LITERAL_REAL .)
    :               reduce using rule 71 (literal -> LITERAL_REAL .)


state 73

    (72) literal -> LITERAL_BOOL .

    THEN            reduce using rule 72 (literal -> LITERAL_BOOL .)
    +               reduce using rule 72 (literal -> LITERAL_BOOL .)
    -               reduce using rule 72 (literal -> LITERAL_BOOL .)
    *               reduce using rule 72 (literal -> LITERAL_BOOL .)
    /               reduce using rule 72 (literal -> LITERAL_BOOL .)
    %               reduce using rule 72 (literal -> LITERAL_BOOL .)
    EQ              reduce using rule 72 (literal -> LITERAL_BOOL .)
    NEQ             reduce using rule 72 (literal -> LITERAL_BOOL .)
    LT              reduce using rule 72 (literal -> LITERAL_BOOL .)
    GT              reduce using rule 72 (literal -> LITERAL_BOOL .)
    LEQ             reduce using rule 72 (literal -> LITERAL_BOOL .)
    GEQ             reduce using rule 72 (literal -> LITERAL_BOOL .)
    AND             reduce using rule 72 (literal -> LITERAL_BOOL .)
    OR              reduce using rule 72 (literal -> LITERAL_BOOL .)
    DO              reduce using rule 72 (literal -> LITERAL_BOOL .)
    OF              reduce using rule 72 (literal -> LITERAL_BOOL .)
    )               reduce using rule 72 (literal -> LITERAL_BOOL .)
    ,               reduce using rule 72 (literal -> LITERAL_BOOL .)
    ]               reduce using rule 72 (literal -> LITERAL_BOOL .)
    END             reduce using rule 72 (literal -> LITERAL_BOOL .)
    ;               reduce using rule 72 (literal -> LITERAL_BOOL .)
    UNTIL           reduce using rule 72 (literal -> LITERAL_BOOL .)
    ELSE            reduce using rule 72 (literal -> LITERAL_BOOL .)
    DOWNTO          reduce using rule 72 (literal -> LITERAL_BOOL .)
    TO              reduce using rule 72 (literal -> LITERAL_BOOL .)
    :               reduce using rule 72 (literal -> LITERAL_BOOL .)


state 74

    (73) literal -> LITERAL_CHAR .

    THEN            reduce using rule 73 (literal -> LITERAL_CHAR .)
    +               reduce using rule 73 (literal -> LITERAL_CHAR .)
    -               reduce using rule 73 (literal -> LITERAL_CHAR .)
    *               reduce using rule 73 (literal -> LITERAL_CHAR .)
    /               reduce using rule 73 (literal -> LITERAL_CHAR .)
    %               reduce using rule 73 (literal -> LITERAL_CHAR .)
    EQ              reduce using rule 73 (literal -> LITERAL_CHAR .)
    NEQ             reduce using rule 73 (literal -> LITERAL_CHAR .)
    LT              reduce using rule 73 (literal -> LITERAL_CHAR .)
    GT              reduce using rule 73 (literal -> LITERAL_CHAR .)
    LEQ             reduce using rule 73 (literal -> LITERAL_CHAR .)
    GEQ             reduce using rule 73 (literal -> LITERAL_CHAR .)
    AND             reduce using rule 73 (literal -> LITERAL_CHAR .)
    OR              reduce using rule 73 (literal -> LITERAL_CHAR .)
    DO              reduce using rule 73 (literal -> LITERAL_CHAR .)
    OF              reduce using rule 73 (literal -> LITERAL_CHAR .)
    )               reduce using rule 73 (literal -> LITERAL_CHAR .)
    ,               reduce using rule 73 (literal -> LITERAL_CHAR .)
    ]               reduce using rule 73 (literal -> LITERAL_CHAR .)
    END             reduce using rule 73 (literal -> LITERAL_CHAR .)
    ;               reduce using rule 73 (literal -> LITERAL_CHAR .)
    UNTIL           reduce using rule 73 (literal -> LITERAL_CHAR .)
    ELSE            reduce using rule 73 (literal -> LITERAL_CHAR .)
    DOWNTO          reduce using rule 73 (literal -> LITERAL_CHAR .)
    TO              reduce using rule 73 (literal -> LITERAL_CHAR .)
    :               reduce using rule 73 (literal -> LITERAL_CHAR .)


state 75

    (74) literal -> LITERAL_STRING .

    THEN            reduce using rule 74 (literal -> LITERAL_STRING .)
    +               reduce using rule 74 (literal -> LITERAL_STRING .)
    -               reduce using rule 74 (literal -> LITERAL_STRING .)
    *               reduce using rule 74 (literal -> LITERAL_STRING .)
    /               reduce using rule 74 (literal -> LITERAL_STRING .)
    %               reduce using rule 74 (literal -> LITERAL_STRING .)
    EQ              reduce using rule 74 (literal -> LITERAL_STRING .)
    NEQ             reduce using rule 74 (literal -> LITERAL_STRING .)
    LT              reduce using rule 74 (literal -> LITERAL_STRING .)
    GT              reduce using rule 74 (literal -> LITERAL_STRING .)
    LEQ             reduce using rule 74 (literal -> LITERAL_STRING .)
    GEQ             reduce using rule 74 (literal -> LITERAL_STRING .)
    AND             reduce using rule 74 (literal -> LITERAL_STRING .)
    OR              reduce using rule 74 (literal -> LITERAL_STRING .)
    DO              reduce using rule 74 (literal -> LITERAL_STRING .)
    OF              reduce using rule 74 (literal -> LITERAL_STRING .)
    )               reduce using rule 74 (literal -> LITERAL_STRING .)
    ,               reduce using rule 74 (literal -> LITERAL_STRING .)
    ]               reduce using rule 74 (literal -> LITERAL_STRING .)
    END             reduce using rule 74 (literal -> LITERAL_STRING .)
    ;               reduce using rule 74 (literal -> LITERAL_STRING .)
    UNTIL           reduce using rule 74 (literal -> LITERAL_STRING .)
    ELSE            reduce using rule 74 (literal -> LITERAL_STRING .)
    DOWNTO          reduce using rule 74 (literal -> LITERAL_STRING .)
    TO              reduce using rule 74 (literal -> LITERAL_STRING .)
    :               reduce using rule 74 (literal -> LITERAL_STRING .)


state 76

    (51) while_stmt -> WHILE exp . DO stmt
    (76) exp -> exp . + exp
    (77) exp -> exp . - exp
    (78) exp -> exp . * exp
    (79) exp -> exp . / exp
    (80) exp -> exp . % exp
    (81) exp -> exp . EQ exp
    (82) exp -> exp . NEQ exp
    (83) exp -> exp . LT exp
    (84) exp -> exp . GT exp
    (85) exp -> exp . LEQ exp
    (86) exp -> exp . GEQ exp
    (87) exp -> exp . AND exp
    (88) exp -> exp . OR exp

    DO              shift and go to state 120
    +               shift and go to state 102
    -               shift and go to state 103
    *               shift and go to state 104
    /               shift and go to state 105
    %               shift and go to state 106
    EQ              shift and go to state 107
    NEQ             shift and go to state 108
    LT              shift and go to state 109
    GT              shift and go to state 110
    LEQ             shift and go to state 111
    GEQ             shift and go to state 112
    AND             shift and go to state 113
    OR              shift and go to state 114


state 77

    (52) repeat_stmt -> REPEAT stmt . semicolon_stmt_list UNTIL exp
    (34) semicolon_stmt_list -> . semicolon_stmt_list ; stmt
    (35) semicolon_stmt_list -> . empty
    (96) empty -> .

    UNTIL           reduce using rule 96 (empty -> .)
    ;               reduce using rule 96 (empty -> .)

    semicolon_stmt_list            shift and go to state 121
    empty                          shift and go to state 56

state 78

    (53) case_stmt -> CASE exp . OF case_exp_list END
    (76) exp -> exp . + exp
    (77) exp -> exp . - exp
    (78) exp -> exp . * exp
    (79) exp -> exp . / exp
    (80) exp -> exp . % exp
    (81) exp -> exp . EQ exp
    (82) exp -> exp . NEQ exp
    (83) exp -> exp . LT exp
    (84) exp -> exp . GT exp
    (85) exp -> exp . LEQ exp
    (86) exp -> exp . GEQ exp
    (87) exp -> exp . AND exp
    (88) exp -> exp . OR exp

    OF              shift and go to state 122
    +               shift and go to state 102
    -               shift and go to state 103
    *               shift and go to state 104
    /               shift and go to state 105
    %               shift and go to state 106
    EQ              shift and go to state 107
    NEQ             shift and go to state 108
    LT              shift and go to state 109
    GT              shift and go to state 110
    LEQ             shift and go to state 111
    GEQ             shift and go to state 112
    AND             shift and go to state 113
    OR              shift and go to state 114


state 79

    (58) goto_stmt -> GOTO ID .

    END             reduce using rule 58 (goto_stmt -> GOTO ID .)
    ;               reduce using rule 58 (goto_stmt -> GOTO ID .)
    UNTIL           reduce using rule 58 (goto_stmt -> GOTO ID .)
    ELSE            reduce using rule 58 (goto_stmt -> GOTO ID .)


state 80

    (32) vartype -> ARRAY [ . LITERAL_INT ] OF vartype
    (33) vartype -> ARRAY [ . LITERAL_INT RANGE LITERAL_INT ] OF vartype

    LITERAL_INT     shift and go to state 123


state 81

    (9) var_list -> var_list var .

    ID              reduce using rule 9 (var_list -> var_list var .)
    BEGIN           reduce using rule 9 (var_list -> var_list var .)
    VAR             reduce using rule 9 (var_list -> var_list var .)
    LABEL           reduce using rule 9 (var_list -> var_list var .)
    CONST           reduce using rule 9 (var_list -> var_list var .)
    PROCEDURE       reduce using rule 9 (var_list -> var_list var .)
    FUNCTION        reduce using rule 9 (var_list -> var_list var .)


state 82

    (11) var -> id_list : . vartype ;
    (12) var -> id_list : . vartype EQ exp ;
    (27) vartype -> . INT
    (28) vartype -> . REAL
    (29) vartype -> . BOOL
    (30) vartype -> . CHAR
    (31) vartype -> . STRING
    (32) vartype -> . ARRAY [ LITERAL_INT ] OF vartype
    (33) vartype -> . ARRAY [ LITERAL_INT RANGE LITERAL_INT ] OF vartype

    INT             shift and go to state 38
    REAL            shift and go to state 39
    BOOL            shift and go to state 40
    CHAR            shift and go to state 41
    STRING          shift and go to state 42
    ARRAY           shift and go to state 43

    vartype                        shift and go to state 124

state 83

    (16) id_list -> ID comma_id_list .
    (17) comma_id_list -> comma_id_list . , ID

    :               reduce using rule 16 (id_list -> ID comma_id_list .)
    ;               reduce using rule 16 (id_list -> ID comma_id_list .)
    EQ              reduce using rule 16 (id_list -> ID comma_id_list .)
    ,               shift and go to state 125


state 84

    (18) comma_id_list -> empty .

    ,               reduce using rule 18 (comma_id_list -> empty .)
    :               reduce using rule 18 (comma_id_list -> empty .)
    ;               reduce using rule 18 (comma_id_list -> empty .)
    EQ              reduce using rule 18 (comma_id_list -> empty .)


state 85

    (6) local -> LABEL id_list ; .

    BEGIN           reduce using rule 6 (local -> LABEL id_list ; .)
    VAR             reduce using rule 6 (local -> LABEL id_list ; .)
    LABEL           reduce using rule 6 (local -> LABEL id_list ; .)
    CONST           reduce using rule 6 (local -> LABEL id_list ; .)
    PROCEDURE       reduce using rule 6 (local -> LABEL id_list ; .)
    FUNCTION        reduce using rule 6 (local -> LABEL id_list ; .)


state 86

    (13) const_exp_list -> const_exp_list const_exp .

    ID              reduce using rule 13 (const_exp_list -> const_exp_list const_exp .)
    BEGIN           reduce using rule 13 (const_exp_list -> const_exp_list const_exp .)
    VAR             reduce using rule 13 (const_exp_list -> const_exp_list const_exp .)
    LABEL           reduce using rule 13 (const_exp_list -> const_exp_list const_exp .)
    CONST           reduce using rule 13 (const_exp_list -> const_exp_list const_exp .)
    PROCEDURE       reduce using rule 13 (const_exp_list -> const_exp_list const_exp .)
    FUNCTION        reduce using rule 13 (const_exp_list -> const_exp_list const_exp .)


state 87

    (15) const_exp -> id_list EQ . literal ;
    (70) literal -> . LITERAL_INT
    (71) literal -> . LITERAL_REAL
    (72) literal -> . LITERAL_BOOL
    (73) literal -> . LITERAL_CHAR
    (74) literal -> . LITERAL_STRING

    LITERAL_INT     shift and go to state 71
    LITERAL_REAL    shift and go to state 72
    LITERAL_BOOL    shift and go to state 73
    LITERAL_CHAR    shift and go to state 74
    LITERAL_STRING  shift and go to state 75

    literal                        shift and go to state 126

state 88

    (8) local -> header ; body . ;

    ;               shift and go to state 127


state 89

    (19) header -> PROCEDURE ID ( . formal_list )
    (20) header -> PROCEDURE ID ( . )
    (23) formal_list -> . formal semicolon_formal_list
    (24) formal -> . id_list : vartype
    (16) id_list -> . ID comma_id_list

    )               shift and go to state 129
    ID              shift and go to state 47

    formal_list                    shift and go to state 128
    formal                         shift and go to state 130
    id_list                        shift and go to state 131

state 90

    (21) header -> FUNCTION ID ( . formal_list ) : vartype
    (22) header -> FUNCTION ID ( . ) : vartype
    (23) formal_list -> . formal semicolon_formal_list
    (24) formal -> . id_list : vartype
    (16) id_list -> . ID comma_id_list

    )               shift and go to state 133
    ID              shift and go to state 47

    formal_list                    shift and go to state 132
    formal                         shift and go to state 130
    id_list                        shift and go to state 131

state 91

    (59) compound_stmt -> BEGIN stmt semicolon_stmt_list END .

    .               reduce using rule 59 (compound_stmt -> BEGIN stmt semicolon_stmt_list END .)
    ;               reduce using rule 59 (compound_stmt -> BEGIN stmt semicolon_stmt_list END .)
    END             reduce using rule 59 (compound_stmt -> BEGIN stmt semicolon_stmt_list END .)
    UNTIL           reduce using rule 59 (compound_stmt -> BEGIN stmt semicolon_stmt_list END .)
    ELSE            reduce using rule 59 (compound_stmt -> BEGIN stmt semicolon_stmt_list END .)


state 92

    (34) semicolon_stmt_list -> semicolon_stmt_list ; . stmt
    (36) stmt -> . ID : non_label_stmt
    (37) stmt -> . non_label_stmt
    (38) non_label_stmt -> . assign_stmt
    (39) non_label_stmt -> . call_stmt
    (40) non_label_stmt -> . for_stmt
    (41) non_label_stmt -> . if_stmt
    (42) non_label_stmt -> . while_stmt
    (43) non_label_stmt -> . repeat_stmt
    (44) non_label_stmt -> . case_stmt
    (45) non_label_stmt -> . goto_stmt
    (46) non_label_stmt -> . compound_stmt
    (47) assign_stmt -> . lvalue ASSIGN exp
    (60) call_stmt -> . ID ( exp comma_exp_list )
    (61) call_stmt -> . vartype ( exp )
    (62) call_stmt -> . ID ( )
    (48) for_stmt -> . FOR ID ASSIGN exp direction exp DO stmt
    (65) if_stmt -> . IF exp THEN stmt else_stmt
    (51) while_stmt -> . WHILE exp DO stmt
    (52) repeat_stmt -> . REPEAT stmt semicolon_stmt_list UNTIL exp
    (53) case_stmt -> . CASE exp OF case_exp_list END
    (58) goto_stmt -> . GOTO ID
    (59) compound_stmt -> . BEGIN stmt semicolon_stmt_list END
    (68) lvalue -> . ID
    (69) lvalue -> . ID [ exp ]
    (27) vartype -> . INT
    (28) vartype -> . REAL
    (29) vartype -> . BOOL
    (30) vartype -> . CHAR
    (31) vartype -> . STRING
    (32) vartype -> . ARRAY [ LITERAL_INT ] OF vartype
    (33) vartype -> . ARRAY [ LITERAL_INT RANGE LITERAL_INT ] OF vartype

    ID              shift and go to state 19
    FOR             shift and go to state 32
    IF              shift and go to state 33
    WHILE           shift and go to state 34
    REPEAT          shift and go to state 35
    CASE            shift and go to state 36
    GOTO            shift and go to state 37
    BEGIN           shift and go to state 11
    INT             shift and go to state 38
    REAL            shift and go to state 39
    BOOL            shift and go to state 40
    CHAR            shift and go to state 41
    STRING          shift and go to state 42
    ARRAY           shift and go to state 43

    stmt                           shift and go to state 134
    non_label_stmt                 shift and go to state 20
    assign_stmt                    shift and go to state 21
    call_stmt                      shift and go to state 22
    for_stmt                       shift and go to state 23
    if_stmt                        shift and go to state 24
    while_stmt                     shift and go to state 25
    repeat_stmt                    shift and go to state 26
    case_stmt                      shift and go to state 27
    goto_stmt                      shift and go to state 28
    compound_stmt                  shift and go to state 29
    lvalue                         shift and go to state 30
    vartype                        shift and go to state 31

state 93

    (60) call_stmt -> ID . ( exp comma_exp_list )
    (62) call_stmt -> ID . ( )
    (68) lvalue -> ID .
    (69) lvalue -> ID . [ exp ]

    (               shift and go to state 58
    ASSIGN          reduce using rule 68 (lvalue -> ID .)
    [               shift and go to state 59


state 94

    (36) stmt -> ID : non_label_stmt .

    END             reduce using rule 36 (stmt -> ID : non_label_stmt .)
    ;               reduce using rule 36 (stmt -> ID : non_label_stmt .)
    UNTIL           reduce using rule 36 (stmt -> ID : non_label_stmt .)
    ELSE            reduce using rule 36 (stmt -> ID : non_label_stmt .)


state 95

    (60) call_stmt -> ID ( exp . comma_exp_list )
    (76) exp -> exp . + exp
    (77) exp -> exp . - exp
    (78) exp -> exp . * exp
    (79) exp -> exp . / exp
    (80) exp -> exp . % exp
    (81) exp -> exp . EQ exp
    (82) exp -> exp . NEQ exp
    (83) exp -> exp . LT exp
    (84) exp -> exp . GT exp
    (85) exp -> exp . LEQ exp
    (86) exp -> exp . GEQ exp
    (87) exp -> exp . AND exp
    (88) exp -> exp . OR exp
    (63) comma_exp_list -> . comma_exp_list , exp
    (64) comma_exp_list -> . empty
    (96) empty -> .

    +               shift and go to state 102
    -               shift and go to state 103
    *               shift and go to state 104
    /               shift and go to state 105
    %               shift and go to state 106
    EQ              shift and go to state 107
    NEQ             shift and go to state 108
    LT              shift and go to state 109
    GT              shift and go to state 110
    LEQ             shift and go to state 111
    GEQ             shift and go to state 112
    AND             shift and go to state 113
    OR              shift and go to state 114
    )               reduce using rule 96 (empty -> .)
    ,               reduce using rule 96 (empty -> .)

    comma_exp_list                 shift and go to state 135
    empty                          shift and go to state 136

state 96

    (62) call_stmt -> ID ( ) .

    END             reduce using rule 62 (call_stmt -> ID ( ) .)
    ;               reduce using rule 62 (call_stmt -> ID ( ) .)
    THEN            reduce using rule 62 (call_stmt -> ID ( ) .)
    +               reduce using rule 62 (call_stmt -> ID ( ) .)
    -               reduce using rule 62 (call_stmt -> ID ( ) .)
    *               reduce using rule 62 (call_stmt -> ID ( ) .)
    /               reduce using rule 62 (call_stmt -> ID ( ) .)
    %               reduce using rule 62 (call_stmt -> ID ( ) .)
    EQ              reduce using rule 62 (call_stmt -> ID ( ) .)
    NEQ             reduce using rule 62 (call_stmt -> ID ( ) .)
    LT              reduce using rule 62 (call_stmt -> ID ( ) .)
    GT              reduce using rule 62 (call_stmt -> ID ( ) .)
    LEQ             reduce using rule 62 (call_stmt -> ID ( ) .)
    GEQ             reduce using rule 62 (call_stmt -> ID ( ) .)
    AND             reduce using rule 62 (call_stmt -> ID ( ) .)
    OR              reduce using rule 62 (call_stmt -> ID ( ) .)
    DO              reduce using rule 62 (call_stmt -> ID ( ) .)
    UNTIL           reduce using rule 62 (call_stmt -> ID ( ) .)
    OF              reduce using rule 62 (call_stmt -> ID ( ) .)
    ELSE            reduce using rule 62 (call_stmt -> ID ( ) .)
    )               reduce using rule 62 (call_stmt -> ID ( ) .)
    ,               reduce using rule 62 (call_stmt -> ID ( ) .)
    ]               reduce using rule 62 (call_stmt -> ID ( ) .)
    DOWNTO          reduce using rule 62 (call_stmt -> ID ( ) .)
    TO              reduce using rule 62 (call_stmt -> ID ( ) .)


state 97

    (69) lvalue -> ID [ exp . ]
    (76) exp -> exp . + exp
    (77) exp -> exp . - exp
    (78) exp -> exp . * exp
    (79) exp -> exp . / exp
    (80) exp -> exp . % exp
    (81) exp -> exp . EQ exp
    (82) exp -> exp . NEQ exp
    (83) exp -> exp . LT exp
    (84) exp -> exp . GT exp
    (85) exp -> exp . LEQ exp
    (86) exp -> exp . GEQ exp
    (87) exp -> exp . AND exp
    (88) exp -> exp . OR exp

    ]               shift and go to state 137
    +               shift and go to state 102
    -               shift and go to state 103
    *               shift and go to state 104
    /               shift and go to state 105
    %               shift and go to state 106
    EQ              shift and go to state 107
    NEQ             shift and go to state 108
    LT              shift and go to state 109
    GT              shift and go to state 110
    LEQ             shift and go to state 111
    GEQ             shift and go to state 112
    AND             shift and go to state 113
    OR              shift and go to state 114


state 98

    (47) assign_stmt -> lvalue ASSIGN exp .
    (76) exp -> exp . + exp
    (77) exp -> exp . - exp
    (78) exp -> exp . * exp
    (79) exp -> exp . / exp
    (80) exp -> exp . % exp
    (81) exp -> exp . EQ exp
    (82) exp -> exp . NEQ exp
    (83) exp -> exp . LT exp
    (84) exp -> exp . GT exp
    (85) exp -> exp . LEQ exp
    (86) exp -> exp . GEQ exp
    (87) exp -> exp . AND exp
    (88) exp -> exp . OR exp

    END             reduce using rule 47 (assign_stmt -> lvalue ASSIGN exp .)
    ;               reduce using rule 47 (assign_stmt -> lvalue ASSIGN exp .)
    UNTIL           reduce using rule 47 (assign_stmt -> lvalue ASSIGN exp .)
    ELSE            reduce using rule 47 (assign_stmt -> lvalue ASSIGN exp .)
    +               shift and go to state 102
    -               shift and go to state 103
    *               shift and go to state 104
    /               shift and go to state 105
    %               shift and go to state 106
    EQ              shift and go to state 107
    NEQ             shift and go to state 108
    LT              shift and go to state 109
    GT              shift and go to state 110
    LEQ             shift and go to state 111
    GEQ             shift and go to state 112
    AND             shift and go to state 113
    OR              shift and go to state 114


state 99

    (61) call_stmt -> vartype ( exp . )
    (76) exp -> exp . + exp
    (77) exp -> exp . - exp
    (78) exp -> exp . * exp
    (79) exp -> exp . / exp
    (80) exp -> exp . % exp
    (81) exp -> exp . EQ exp
    (82) exp -> exp . NEQ exp
    (83) exp -> exp . LT exp
    (84) exp -> exp . GT exp
    (85) exp -> exp . LEQ exp
    (86) exp -> exp . GEQ exp
    (87) exp -> exp . AND exp
    (88) exp -> exp . OR exp

    )               shift and go to state 138
    +               shift and go to state 102
    -               shift and go to state 103
    *               shift and go to state 104
    /               shift and go to state 105
    %               shift and go to state 106
    EQ              shift and go to state 107
    NEQ             shift and go to state 108
    LT              shift and go to state 109
    GT              shift and go to state 110
    LEQ             shift and go to state 111
    GEQ             shift and go to state 112
    AND             shift and go to state 113
    OR              shift and go to state 114


state 100

    (48) for_stmt -> FOR ID ASSIGN . exp direction exp DO stmt
    (75) exp -> . call_stmt
    (76) exp -> . exp + exp
    (77) exp -> . exp - exp
    (78) exp -> . exp * exp
    (79) exp -> . exp / exp
    (80) exp -> . exp % exp
    (81) exp -> . exp EQ exp
    (82) exp -> . exp NEQ exp
    (83) exp -> . exp LT exp
    (84) exp -> . exp GT exp
    (85) exp -> . exp LEQ exp
    (86) exp -> . exp GEQ exp
    (87) exp -> . exp AND exp
    (88) exp -> . exp OR exp
    (89) exp -> . NOT exp
    (90) exp -> . - exp
    (91) exp -> . + exp
    (92) exp -> . ( exp )
    (93) exp -> . ID
    (94) exp -> . literal
    (95) exp -> . ID [ exp ]
    (60) call_stmt -> . ID ( exp comma_exp_list )
    (61) call_stmt -> . vartype ( exp )
    (62) call_stmt -> . ID ( )
    (70) literal -> . LITERAL_INT
    (71) literal -> . LITERAL_REAL
    (72) literal -> . LITERAL_BOOL
    (73) literal -> . LITERAL_CHAR
    (74) literal -> . LITERAL_STRING
    (27) vartype -> . INT
    (28) vartype -> . REAL
    (29) vartype -> . BOOL
    (30) vartype -> . CHAR
    (31) vartype -> . STRING
    (32) vartype -> . ARRAY [ LITERAL_INT ] OF vartype
    (33) vartype -> . ARRAY [ LITERAL_INT RANGE LITERAL_INT ] OF vartype

    NOT             shift and go to state 67
    -               shift and go to state 66
    +               shift and go to state 65
    (               shift and go to state 68
    ID              shift and go to state 69
    LITERAL_INT     shift and go to state 71
    LITERAL_REAL    shift and go to state 72
    LITERAL_BOOL    shift and go to state 73
    LITERAL_CHAR    shift and go to state 74
    LITERAL_STRING  shift and go to state 75
    INT             shift and go to state 38
    REAL            shift and go to state 39
    BOOL            shift and go to state 40
    CHAR            shift and go to state 41
    STRING          shift and go to state 42
    ARRAY           shift and go to state 43

    exp                            shift and go to state 139
    call_stmt                      shift and go to state 64
    literal                        shift and go to state 70
    vartype                        shift and go to state 31

state 101

    (65) if_stmt -> IF exp THEN . stmt else_stmt
    (36) stmt -> . ID : non_label_stmt
    (37) stmt -> . non_label_stmt
    (38) non_label_stmt -> . assign_stmt
    (39) non_label_stmt -> . call_stmt
    (40) non_label_stmt -> . for_stmt
    (41) non_label_stmt -> . if_stmt
    (42) non_label_stmt -> . while_stmt
    (43) non_label_stmt -> . repeat_stmt
    (44) non_label_stmt -> . case_stmt
    (45) non_label_stmt -> . goto_stmt
    (46) non_label_stmt -> . compound_stmt
    (47) assign_stmt -> . lvalue ASSIGN exp
    (60) call_stmt -> . ID ( exp comma_exp_list )
    (61) call_stmt -> . vartype ( exp )
    (62) call_stmt -> . ID ( )
    (48) for_stmt -> . FOR ID ASSIGN exp direction exp DO stmt
    (65) if_stmt -> . IF exp THEN stmt else_stmt
    (51) while_stmt -> . WHILE exp DO stmt
    (52) repeat_stmt -> . REPEAT stmt semicolon_stmt_list UNTIL exp
    (53) case_stmt -> . CASE exp OF case_exp_list END
    (58) goto_stmt -> . GOTO ID
    (59) compound_stmt -> . BEGIN stmt semicolon_stmt_list END
    (68) lvalue -> . ID
    (69) lvalue -> . ID [ exp ]
    (27) vartype -> . INT
    (28) vartype -> . REAL
    (29) vartype -> . BOOL
    (30) vartype -> . CHAR
    (31) vartype -> . STRING
    (32) vartype -> . ARRAY [ LITERAL_INT ] OF vartype
    (33) vartype -> . ARRAY [ LITERAL_INT RANGE LITERAL_INT ] OF vartype

    ID              shift and go to state 19
    FOR             shift and go to state 32
    IF              shift and go to state 33
    WHILE           shift and go to state 34
    REPEAT          shift and go to state 35
    CASE            shift and go to state 36
    GOTO            shift and go to state 37
    BEGIN           shift and go to state 11
    INT             shift and go to state 38
    REAL            shift and go to state 39
    BOOL            shift and go to state 40
    CHAR            shift and go to state 41
    STRING          shift and go to state 42
    ARRAY           shift and go to state 43

    stmt                           shift and go to state 140
    non_label_stmt                 shift and go to state 20
    assign_stmt                    shift and go to state 21
    call_stmt                      shift and go to state 22
    for_stmt                       shift and go to state 23
    if_stmt                        shift and go to state 24
    while_stmt                     shift and go to state 25
    repeat_stmt                    shift and go to state 26
    case_stmt                      shift and go to state 27
    goto_stmt                      shift and go to state 28
    compound_stmt                  shift and go to state 29
    lvalue                         shift and go to state 30
    vartype                        shift and go to state 31

state 102

    (76) exp -> exp + . exp
    (75) exp -> . call_stmt
    (76) exp -> . exp + exp
    (77) exp -> . exp - exp
    (78) exp -> . exp * exp
    (79) exp -> . exp / exp
    (80) exp -> . exp % exp
    (81) exp -> . exp EQ exp
    (82) exp -> . exp NEQ exp
    (83) exp -> . exp LT exp
    (84) exp -> . exp GT exp
    (85) exp -> . exp LEQ exp
    (86) exp -> . exp GEQ exp
    (87) exp -> . exp AND exp
    (88) exp -> . exp OR exp
    (89) exp -> . NOT exp
    (90) exp -> . - exp
    (91) exp -> . + exp
    (92) exp -> . ( exp )
    (93) exp -> . ID
    (94) exp -> . literal
    (95) exp -> . ID [ exp ]
    (60) call_stmt -> . ID ( exp comma_exp_list )
    (61) call_stmt -> . vartype ( exp )
    (62) call_stmt -> . ID ( )
    (70) literal -> . LITERAL_INT
    (71) literal -> . LITERAL_REAL
    (72) literal -> . LITERAL_BOOL
    (73) literal -> . LITERAL_CHAR
    (74) literal -> . LITERAL_STRING
    (27) vartype -> . INT
    (28) vartype -> . REAL
    (29) vartype -> . BOOL
    (30) vartype -> . CHAR
    (31) vartype -> . STRING
    (32) vartype -> . ARRAY [ LITERAL_INT ] OF vartype
    (33) vartype -> . ARRAY [ LITERAL_INT RANGE LITERAL_INT ] OF vartype

    NOT             shift and go to state 67
    -               shift and go to state 66
    +               shift and go to state 65
    (               shift and go to state 68
    ID              shift and go to state 69
    LITERAL_INT     shift and go to state 71
    LITERAL_REAL    shift and go to state 72
    LITERAL_BOOL    shift and go to state 73
    LITERAL_CHAR    shift and go to state 74
    LITERAL_STRING  shift and go to state 75
    INT             shift and go to state 38
    REAL            shift and go to state 39
    BOOL            shift and go to state 40
    CHAR            shift and go to state 41
    STRING          shift and go to state 42
    ARRAY           shift and go to state 43

    exp                            shift and go to state 141
    call_stmt                      shift and go to state 64
    literal                        shift and go to state 70
    vartype                        shift and go to state 31

state 103

    (77) exp -> exp - . exp
    (75) exp -> . call_stmt
    (76) exp -> . exp + exp
    (77) exp -> . exp - exp
    (78) exp -> . exp * exp
    (79) exp -> . exp / exp
    (80) exp -> . exp % exp
    (81) exp -> . exp EQ exp
    (82) exp -> . exp NEQ exp
    (83) exp -> . exp LT exp
    (84) exp -> . exp GT exp
    (85) exp -> . exp LEQ exp
    (86) exp -> . exp GEQ exp
    (87) exp -> . exp AND exp
    (88) exp -> . exp OR exp
    (89) exp -> . NOT exp
    (90) exp -> . - exp
    (91) exp -> . + exp
    (92) exp -> . ( exp )
    (93) exp -> . ID
    (94) exp -> . literal
    (95) exp -> . ID [ exp ]
    (60) call_stmt -> . ID ( exp comma_exp_list )
    (61) call_stmt -> . vartype ( exp )
    (62) call_stmt -> . ID ( )
    (70) literal -> . LITERAL_INT
    (71) literal -> . LITERAL_REAL
    (72) literal -> . LITERAL_BOOL
    (73) literal -> . LITERAL_CHAR
    (74) literal -> . LITERAL_STRING
    (27) vartype -> . INT
    (28) vartype -> . REAL
    (29) vartype -> . BOOL
    (30) vartype -> . CHAR
    (31) vartype -> . STRING
    (32) vartype -> . ARRAY [ LITERAL_INT ] OF vartype
    (33) vartype -> . ARRAY [ LITERAL_INT RANGE LITERAL_INT ] OF vartype

    NOT             shift and go to state 67
    -               shift and go to state 66
    +               shift and go to state 65
    (               shift and go to state 68
    ID              shift and go to state 69
    LITERAL_INT     shift and go to state 71
    LITERAL_REAL    shift and go to state 72
    LITERAL_BOOL    shift and go to state 73
    LITERAL_CHAR    shift and go to state 74
    LITERAL_STRING  shift and go to state 75
    INT             shift and go to state 38
    REAL            shift and go to state 39
    BOOL            shift and go to state 40
    CHAR            shift and go to state 41
    STRING          shift and go to state 42
    ARRAY           shift and go to state 43

    exp                            shift and go to state 142
    call_stmt                      shift and go to state 64
    literal                        shift and go to state 70
    vartype                        shift and go to state 31

state 104

    (78) exp -> exp * . exp
    (75) exp -> . call_stmt
    (76) exp -> . exp + exp
    (77) exp -> . exp - exp
    (78) exp -> . exp * exp
    (79) exp -> . exp / exp
    (80) exp -> . exp % exp
    (81) exp -> . exp EQ exp
    (82) exp -> . exp NEQ exp
    (83) exp -> . exp LT exp
    (84) exp -> . exp GT exp
    (85) exp -> . exp LEQ exp
    (86) exp -> . exp GEQ exp
    (87) exp -> . exp AND exp
    (88) exp -> . exp OR exp
    (89) exp -> . NOT exp
    (90) exp -> . - exp
    (91) exp -> . + exp
    (92) exp -> . ( exp )
    (93) exp -> . ID
    (94) exp -> . literal
    (95) exp -> . ID [ exp ]
    (60) call_stmt -> . ID ( exp comma_exp_list )
    (61) call_stmt -> . vartype ( exp )
    (62) call_stmt -> . ID ( )
    (70) literal -> . LITERAL_INT
    (71) literal -> . LITERAL_REAL
    (72) literal -> . LITERAL_BOOL
    (73) literal -> . LITERAL_CHAR
    (74) literal -> . LITERAL_STRING
    (27) vartype -> . INT
    (28) vartype -> . REAL
    (29) vartype -> . BOOL
    (30) vartype -> . CHAR
    (31) vartype -> . STRING
    (32) vartype -> . ARRAY [ LITERAL_INT ] OF vartype
    (33) vartype -> . ARRAY [ LITERAL_INT RANGE LITERAL_INT ] OF vartype

    NOT             shift and go to state 67
    -               shift and go to state 66
    +               shift and go to state 65
    (               shift and go to state 68
    ID              shift and go to state 69
    LITERAL_INT     shift and go to state 71
    LITERAL_REAL    shift and go to state 72
    LITERAL_BOOL    shift and go to state 73
    LITERAL_CHAR    shift and go to state 74
    LITERAL_STRING  shift and go to state 75
    INT             shift and go to state 38
    REAL            shift and go to state 39
    BOOL            shift and go to state 40
    CHAR            shift and go to state 41
    STRING          shift and go to state 42
    ARRAY           shift and go to state 43

    exp                            shift and go to state 143
    call_stmt                      shift and go to state 64
    literal                        shift and go to state 70
    vartype                        shift and go to state 31

state 105

    (79) exp -> exp / . exp
    (75) exp -> . call_stmt
    (76) exp -> . exp + exp
    (77) exp -> . exp - exp
    (78) exp -> . exp * exp
    (79) exp -> . exp / exp
    (80) exp -> . exp % exp
    (81) exp -> . exp EQ exp
    (82) exp -> . exp NEQ exp
    (83) exp -> . exp LT exp
    (84) exp -> . exp GT exp
    (85) exp -> . exp LEQ exp
    (86) exp -> . exp GEQ exp
    (87) exp -> . exp AND exp
    (88) exp -> . exp OR exp
    (89) exp -> . NOT exp
    (90) exp -> . - exp
    (91) exp -> . + exp
    (92) exp -> . ( exp )
    (93) exp -> . ID
    (94) exp -> . literal
    (95) exp -> . ID [ exp ]
    (60) call_stmt -> . ID ( exp comma_exp_list )
    (61) call_stmt -> . vartype ( exp )
    (62) call_stmt -> . ID ( )
    (70) literal -> . LITERAL_INT
    (71) literal -> . LITERAL_REAL
    (72) literal -> . LITERAL_BOOL
    (73) literal -> . LITERAL_CHAR
    (74) literal -> . LITERAL_STRING
    (27) vartype -> . INT
    (28) vartype -> . REAL
    (29) vartype -> . BOOL
    (30) vartype -> . CHAR
    (31) vartype -> . STRING
    (32) vartype -> . ARRAY [ LITERAL_INT ] OF vartype
    (33) vartype -> . ARRAY [ LITERAL_INT RANGE LITERAL_INT ] OF vartype

    NOT             shift and go to state 67
    -               shift and go to state 66
    +               shift and go to state 65
    (               shift and go to state 68
    ID              shift and go to state 69
    LITERAL_INT     shift and go to state 71
    LITERAL_REAL    shift and go to state 72
    LITERAL_BOOL    shift and go to state 73
    LITERAL_CHAR    shift and go to state 74
    LITERAL_STRING  shift and go to state 75
    INT             shift and go to state 38
    REAL            shift and go to state 39
    BOOL            shift and go to state 40
    CHAR            shift and go to state 41
    STRING          shift and go to state 42
    ARRAY           shift and go to state 43

    exp                            shift and go to state 144
    call_stmt                      shift and go to state 64
    literal                        shift and go to state 70
    vartype                        shift and go to state 31

state 106

    (80) exp -> exp % . exp
    (75) exp -> . call_stmt
    (76) exp -> . exp + exp
    (77) exp -> . exp - exp
    (78) exp -> . exp * exp
    (79) exp -> . exp / exp
    (80) exp -> . exp % exp
    (81) exp -> . exp EQ exp
    (82) exp -> . exp NEQ exp
    (83) exp -> . exp LT exp
    (84) exp -> . exp GT exp
    (85) exp -> . exp LEQ exp
    (86) exp -> . exp GEQ exp
    (87) exp -> . exp AND exp
    (88) exp -> . exp OR exp
    (89) exp -> . NOT exp
    (90) exp -> . - exp
    (91) exp -> . + exp
    (92) exp -> . ( exp )
    (93) exp -> . ID
    (94) exp -> . literal
    (95) exp -> . ID [ exp ]
    (60) call_stmt -> . ID ( exp comma_exp_list )
    (61) call_stmt -> . vartype ( exp )
    (62) call_stmt -> . ID ( )
    (70) literal -> . LITERAL_INT
    (71) literal -> . LITERAL_REAL
    (72) literal -> . LITERAL_BOOL
    (73) literal -> . LITERAL_CHAR
    (74) literal -> . LITERAL_STRING
    (27) vartype -> . INT
    (28) vartype -> . REAL
    (29) vartype -> . BOOL
    (30) vartype -> . CHAR
    (31) vartype -> . STRING
    (32) vartype -> . ARRAY [ LITERAL_INT ] OF vartype
    (33) vartype -> . ARRAY [ LITERAL_INT RANGE LITERAL_INT ] OF vartype

    NOT             shift and go to state 67
    -               shift and go to state 66
    +               shift and go to state 65
    (               shift and go to state 68
    ID              shift and go to state 69
    LITERAL_INT     shift and go to state 71
    LITERAL_REAL    shift and go to state 72
    LITERAL_BOOL    shift and go to state 73
    LITERAL_CHAR    shift and go to state 74
    LITERAL_STRING  shift and go to state 75
    INT             shift and go to state 38
    REAL            shift and go to state 39
    BOOL            shift and go to state 40
    CHAR            shift and go to state 41
    STRING          shift and go to state 42
    ARRAY           shift and go to state 43

    exp                            shift and go to state 145
    call_stmt                      shift and go to state 64
    literal                        shift and go to state 70
    vartype                        shift and go to state 31

state 107

    (81) exp -> exp EQ . exp
    (75) exp -> . call_stmt
    (76) exp -> . exp + exp
    (77) exp -> . exp - exp
    (78) exp -> . exp * exp
    (79) exp -> . exp / exp
    (80) exp -> . exp % exp
    (81) exp -> . exp EQ exp
    (82) exp -> . exp NEQ exp
    (83) exp -> . exp LT exp
    (84) exp -> . exp GT exp
    (85) exp -> . exp LEQ exp
    (86) exp -> . exp GEQ exp
    (87) exp -> . exp AND exp
    (88) exp -> . exp OR exp
    (89) exp -> . NOT exp
    (90) exp -> . - exp
    (91) exp -> . + exp
    (92) exp -> . ( exp )
    (93) exp -> . ID
    (94) exp -> . literal
    (95) exp -> . ID [ exp ]
    (60) call_stmt -> . ID ( exp comma_exp_list )
    (61) call_stmt -> . vartype ( exp )
    (62) call_stmt -> . ID ( )
    (70) literal -> . LITERAL_INT
    (71) literal -> . LITERAL_REAL
    (72) literal -> . LITERAL_BOOL
    (73) literal -> . LITERAL_CHAR
    (74) literal -> . LITERAL_STRING
    (27) vartype -> . INT
    (28) vartype -> . REAL
    (29) vartype -> . BOOL
    (30) vartype -> . CHAR
    (31) vartype -> . STRING
    (32) vartype -> . ARRAY [ LITERAL_INT ] OF vartype
    (33) vartype -> . ARRAY [ LITERAL_INT RANGE LITERAL_INT ] OF vartype

    NOT             shift and go to state 67
    -               shift and go to state 66
    +               shift and go to state 65
    (               shift and go to state 68
    ID              shift and go to state 69
    LITERAL_INT     shift and go to state 71
    LITERAL_REAL    shift and go to state 72
    LITERAL_BOOL    shift and go to state 73
    LITERAL_CHAR    shift and go to state 74
    LITERAL_STRING  shift and go to state 75
    INT             shift and go to state 38
    REAL            shift and go to state 39
    BOOL            shift and go to state 40
    CHAR            shift and go to state 41
    STRING          shift and go to state 42
    ARRAY           shift and go to state 43

    exp                            shift and go to state 146
    call_stmt                      shift and go to state 64
    literal                        shift and go to state 70
    vartype                        shift and go to state 31

state 108

    (82) exp -> exp NEQ . exp
    (75) exp -> . call_stmt
    (76) exp -> . exp + exp
    (77) exp -> . exp - exp
    (78) exp -> . exp * exp
    (79) exp -> . exp / exp
    (80) exp -> . exp % exp
    (81) exp -> . exp EQ exp
    (82) exp -> . exp NEQ exp
    (83) exp -> . exp LT exp
    (84) exp -> . exp GT exp
    (85) exp -> . exp LEQ exp
    (86) exp -> . exp GEQ exp
    (87) exp -> . exp AND exp
    (88) exp -> . exp OR exp
    (89) exp -> . NOT exp
    (90) exp -> . - exp
    (91) exp -> . + exp
    (92) exp -> . ( exp )
    (93) exp -> . ID
    (94) exp -> . literal
    (95) exp -> . ID [ exp ]
    (60) call_stmt -> . ID ( exp comma_exp_list )
    (61) call_stmt -> . vartype ( exp )
    (62) call_stmt -> . ID ( )
    (70) literal -> . LITERAL_INT
    (71) literal -> . LITERAL_REAL
    (72) literal -> . LITERAL_BOOL
    (73) literal -> . LITERAL_CHAR
    (74) literal -> . LITERAL_STRING
    (27) vartype -> . INT
    (28) vartype -> . REAL
    (29) vartype -> . BOOL
    (30) vartype -> . CHAR
    (31) vartype -> . STRING
    (32) vartype -> . ARRAY [ LITERAL_INT ] OF vartype
    (33) vartype -> . ARRAY [ LITERAL_INT RANGE LITERAL_INT ] OF vartype

    NOT             shift and go to state 67
    -               shift and go to state 66
    +               shift and go to state 65
    (               shift and go to state 68
    ID              shift and go to state 69
    LITERAL_INT     shift and go to state 71
    LITERAL_REAL    shift and go to state 72
    LITERAL_BOOL    shift and go to state 73
    LITERAL_CHAR    shift and go to state 74
    LITERAL_STRING  shift and go to state 75
    INT             shift and go to state 38
    REAL            shift and go to state 39
    BOOL            shift and go to state 40
    CHAR            shift and go to state 41
    STRING          shift and go to state 42
    ARRAY           shift and go to state 43

    exp                            shift and go to state 147
    call_stmt                      shift and go to state 64
    literal                        shift and go to state 70
    vartype                        shift and go to state 31

state 109

    (83) exp -> exp LT . exp
    (75) exp -> . call_stmt
    (76) exp -> . exp + exp
    (77) exp -> . exp - exp
    (78) exp -> . exp * exp
    (79) exp -> . exp / exp
    (80) exp -> . exp % exp
    (81) exp -> . exp EQ exp
    (82) exp -> . exp NEQ exp
    (83) exp -> . exp LT exp
    (84) exp -> . exp GT exp
    (85) exp -> . exp LEQ exp
    (86) exp -> . exp GEQ exp
    (87) exp -> . exp AND exp
    (88) exp -> . exp OR exp
    (89) exp -> . NOT exp
    (90) exp -> . - exp
    (91) exp -> . + exp
    (92) exp -> . ( exp )
    (93) exp -> . ID
    (94) exp -> . literal
    (95) exp -> . ID [ exp ]
    (60) call_stmt -> . ID ( exp comma_exp_list )
    (61) call_stmt -> . vartype ( exp )
    (62) call_stmt -> . ID ( )
    (70) literal -> . LITERAL_INT
    (71) literal -> . LITERAL_REAL
    (72) literal -> . LITERAL_BOOL
    (73) literal -> . LITERAL_CHAR
    (74) literal -> . LITERAL_STRING
    (27) vartype -> . INT
    (28) vartype -> . REAL
    (29) vartype -> . BOOL
    (30) vartype -> . CHAR
    (31) vartype -> . STRING
    (32) vartype -> . ARRAY [ LITERAL_INT ] OF vartype
    (33) vartype -> . ARRAY [ LITERAL_INT RANGE LITERAL_INT ] OF vartype

    NOT             shift and go to state 67
    -               shift and go to state 66
    +               shift and go to state 65
    (               shift and go to state 68
    ID              shift and go to state 69
    LITERAL_INT     shift and go to state 71
    LITERAL_REAL    shift and go to state 72
    LITERAL_BOOL    shift and go to state 73
    LITERAL_CHAR    shift and go to state 74
    LITERAL_STRING  shift and go to state 75
    INT             shift and go to state 38
    REAL            shift and go to state 39
    BOOL            shift and go to state 40
    CHAR            shift and go to state 41
    STRING          shift and go to state 42
    ARRAY           shift and go to state 43

    exp                            shift and go to state 148
    call_stmt                      shift and go to state 64
    literal                        shift and go to state 70
    vartype                        shift and go to state 31

state 110

    (84) exp -> exp GT . exp
    (75) exp -> . call_stmt
    (76) exp -> . exp + exp
    (77) exp -> . exp - exp
    (78) exp -> . exp * exp
    (79) exp -> . exp / exp
    (80) exp -> . exp % exp
    (81) exp -> . exp EQ exp
    (82) exp -> . exp NEQ exp
    (83) exp -> . exp LT exp
    (84) exp -> . exp GT exp
    (85) exp -> . exp LEQ exp
    (86) exp -> . exp GEQ exp
    (87) exp -> . exp AND exp
    (88) exp -> . exp OR exp
    (89) exp -> . NOT exp
    (90) exp -> . - exp
    (91) exp -> . + exp
    (92) exp -> . ( exp )
    (93) exp -> . ID
    (94) exp -> . literal
    (95) exp -> . ID [ exp ]
    (60) call_stmt -> . ID ( exp comma_exp_list )
    (61) call_stmt -> . vartype ( exp )
    (62) call_stmt -> . ID ( )
    (70) literal -> . LITERAL_INT
    (71) literal -> . LITERAL_REAL
    (72) literal -> . LITERAL_BOOL
    (73) literal -> . LITERAL_CHAR
    (74) literal -> . LITERAL_STRING
    (27) vartype -> . INT
    (28) vartype -> . REAL
    (29) vartype -> . BOOL
    (30) vartype -> . CHAR
    (31) vartype -> . STRING
    (32) vartype -> . ARRAY [ LITERAL_INT ] OF vartype
    (33) vartype -> . ARRAY [ LITERAL_INT RANGE LITERAL_INT ] OF vartype

    NOT             shift and go to state 67
    -               shift and go to state 66
    +               shift and go to state 65
    (               shift and go to state 68
    ID              shift and go to state 69
    LITERAL_INT     shift and go to state 71
    LITERAL_REAL    shift and go to state 72
    LITERAL_BOOL    shift and go to state 73
    LITERAL_CHAR    shift and go to state 74
    LITERAL_STRING  shift and go to state 75
    INT             shift and go to state 38
    REAL            shift and go to state 39
    BOOL            shift and go to state 40
    CHAR            shift and go to state 41
    STRING          shift and go to state 42
    ARRAY           shift and go to state 43

    exp                            shift and go to state 149
    call_stmt                      shift and go to state 64
    literal                        shift and go to state 70
    vartype                        shift and go to state 31

state 111

    (85) exp -> exp LEQ . exp
    (75) exp -> . call_stmt
    (76) exp -> . exp + exp
    (77) exp -> . exp - exp
    (78) exp -> . exp * exp
    (79) exp -> . exp / exp
    (80) exp -> . exp % exp
    (81) exp -> . exp EQ exp
    (82) exp -> . exp NEQ exp
    (83) exp -> . exp LT exp
    (84) exp -> . exp GT exp
    (85) exp -> . exp LEQ exp
    (86) exp -> . exp GEQ exp
    (87) exp -> . exp AND exp
    (88) exp -> . exp OR exp
    (89) exp -> . NOT exp
    (90) exp -> . - exp
    (91) exp -> . + exp
    (92) exp -> . ( exp )
    (93) exp -> . ID
    (94) exp -> . literal
    (95) exp -> . ID [ exp ]
    (60) call_stmt -> . ID ( exp comma_exp_list )
    (61) call_stmt -> . vartype ( exp )
    (62) call_stmt -> . ID ( )
    (70) literal -> . LITERAL_INT
    (71) literal -> . LITERAL_REAL
    (72) literal -> . LITERAL_BOOL
    (73) literal -> . LITERAL_CHAR
    (74) literal -> . LITERAL_STRING
    (27) vartype -> . INT
    (28) vartype -> . REAL
    (29) vartype -> . BOOL
    (30) vartype -> . CHAR
    (31) vartype -> . STRING
    (32) vartype -> . ARRAY [ LITERAL_INT ] OF vartype
    (33) vartype -> . ARRAY [ LITERAL_INT RANGE LITERAL_INT ] OF vartype

    NOT             shift and go to state 67
    -               shift and go to state 66
    +               shift and go to state 65
    (               shift and go to state 68
    ID              shift and go to state 69
    LITERAL_INT     shift and go to state 71
    LITERAL_REAL    shift and go to state 72
    LITERAL_BOOL    shift and go to state 73
    LITERAL_CHAR    shift and go to state 74
    LITERAL_STRING  shift and go to state 75
    INT             shift and go to state 38
    REAL            shift and go to state 39
    BOOL            shift and go to state 40
    CHAR            shift and go to state 41
    STRING          shift and go to state 42
    ARRAY           shift and go to state 43

    exp                            shift and go to state 150
    call_stmt                      shift and go to state 64
    literal                        shift and go to state 70
    vartype                        shift and go to state 31

state 112

    (86) exp -> exp GEQ . exp
    (75) exp -> . call_stmt
    (76) exp -> . exp + exp
    (77) exp -> . exp - exp
    (78) exp -> . exp * exp
    (79) exp -> . exp / exp
    (80) exp -> . exp % exp
    (81) exp -> . exp EQ exp
    (82) exp -> . exp NEQ exp
    (83) exp -> . exp LT exp
    (84) exp -> . exp GT exp
    (85) exp -> . exp LEQ exp
    (86) exp -> . exp GEQ exp
    (87) exp -> . exp AND exp
    (88) exp -> . exp OR exp
    (89) exp -> . NOT exp
    (90) exp -> . - exp
    (91) exp -> . + exp
    (92) exp -> . ( exp )
    (93) exp -> . ID
    (94) exp -> . literal
    (95) exp -> . ID [ exp ]
    (60) call_stmt -> . ID ( exp comma_exp_list )
    (61) call_stmt -> . vartype ( exp )
    (62) call_stmt -> . ID ( )
    (70) literal -> . LITERAL_INT
    (71) literal -> . LITERAL_REAL
    (72) literal -> . LITERAL_BOOL
    (73) literal -> . LITERAL_CHAR
    (74) literal -> . LITERAL_STRING
    (27) vartype -> . INT
    (28) vartype -> . REAL
    (29) vartype -> . BOOL
    (30) vartype -> . CHAR
    (31) vartype -> . STRING
    (32) vartype -> . ARRAY [ LITERAL_INT ] OF vartype
    (33) vartype -> . ARRAY [ LITERAL_INT RANGE LITERAL_INT ] OF vartype

    NOT             shift and go to state 67
    -               shift and go to state 66
    +               shift and go to state 65
    (               shift and go to state 68
    ID              shift and go to state 69
    LITERAL_INT     shift and go to state 71
    LITERAL_REAL    shift and go to state 72
    LITERAL_BOOL    shift and go to state 73
    LITERAL_CHAR    shift and go to state 74
    LITERAL_STRING  shift and go to state 75
    INT             shift and go to state 38
    REAL            shift and go to state 39
    BOOL            shift and go to state 40
    CHAR            shift and go to state 41
    STRING          shift and go to state 42
    ARRAY           shift and go to state 43

    exp                            shift and go to state 151
    call_stmt                      shift and go to state 64
    literal                        shift and go to state 70
    vartype                        shift and go to state 31

state 113

    (87) exp -> exp AND . exp
    (75) exp -> . call_stmt
    (76) exp -> . exp + exp
    (77) exp -> . exp - exp
    (78) exp -> . exp * exp
    (79) exp -> . exp / exp
    (80) exp -> . exp % exp
    (81) exp -> . exp EQ exp
    (82) exp -> . exp NEQ exp
    (83) exp -> . exp LT exp
    (84) exp -> . exp GT exp
    (85) exp -> . exp LEQ exp
    (86) exp -> . exp GEQ exp
    (87) exp -> . exp AND exp
    (88) exp -> . exp OR exp
    (89) exp -> . NOT exp
    (90) exp -> . - exp
    (91) exp -> . + exp
    (92) exp -> . ( exp )
    (93) exp -> . ID
    (94) exp -> . literal
    (95) exp -> . ID [ exp ]
    (60) call_stmt -> . ID ( exp comma_exp_list )
    (61) call_stmt -> . vartype ( exp )
    (62) call_stmt -> . ID ( )
    (70) literal -> . LITERAL_INT
    (71) literal -> . LITERAL_REAL
    (72) literal -> . LITERAL_BOOL
    (73) literal -> . LITERAL_CHAR
    (74) literal -> . LITERAL_STRING
    (27) vartype -> . INT
    (28) vartype -> . REAL
    (29) vartype -> . BOOL
    (30) vartype -> . CHAR
    (31) vartype -> . STRING
    (32) vartype -> . ARRAY [ LITERAL_INT ] OF vartype
    (33) vartype -> . ARRAY [ LITERAL_INT RANGE LITERAL_INT ] OF vartype

    NOT             shift and go to state 67
    -               shift and go to state 66
    +               shift and go to state 65
    (               shift and go to state 68
    ID              shift and go to state 69
    LITERAL_INT     shift and go to state 71
    LITERAL_REAL    shift and go to state 72
    LITERAL_BOOL    shift and go to state 73
    LITERAL_CHAR    shift and go to state 74
    LITERAL_STRING  shift and go to state 75
    INT             shift and go to state 38
    REAL            shift and go to state 39
    BOOL            shift and go to state 40
    CHAR            shift and go to state 41
    STRING          shift and go to state 42
    ARRAY           shift and go to state 43

    exp                            shift and go to state 152
    call_stmt                      shift and go to state 64
    literal                        shift and go to state 70
    vartype                        shift and go to state 31

state 114

    (88) exp -> exp OR . exp
    (75) exp -> . call_stmt
    (76) exp -> . exp + exp
    (77) exp -> . exp - exp
    (78) exp -> . exp * exp
    (79) exp -> . exp / exp
    (80) exp -> . exp % exp
    (81) exp -> . exp EQ exp
    (82) exp -> . exp NEQ exp
    (83) exp -> . exp LT exp
    (84) exp -> . exp GT exp
    (85) exp -> . exp LEQ exp
    (86) exp -> . exp GEQ exp
    (87) exp -> . exp AND exp
    (88) exp -> . exp OR exp
    (89) exp -> . NOT exp
    (90) exp -> . - exp
    (91) exp -> . + exp
    (92) exp -> . ( exp )
    (93) exp -> . ID
    (94) exp -> . literal
    (95) exp -> . ID [ exp ]
    (60) call_stmt -> . ID ( exp comma_exp_list )
    (61) call_stmt -> . vartype ( exp )
    (62) call_stmt -> . ID ( )
    (70) literal -> . LITERAL_INT
    (71) literal -> . LITERAL_REAL
    (72) literal -> . LITERAL_BOOL
    (73) literal -> . LITERAL_CHAR
    (74) literal -> . LITERAL_STRING
    (27) vartype -> . INT
    (28) vartype -> . REAL
    (29) vartype -> . BOOL
    (30) vartype -> . CHAR
    (31) vartype -> . STRING
    (32) vartype -> . ARRAY [ LITERAL_INT ] OF vartype
    (33) vartype -> . ARRAY [ LITERAL_INT RANGE LITERAL_INT ] OF vartype

    NOT             shift and go to state 67
    -               shift and go to state 66
    +               shift and go to state 65
    (               shift and go to state 68
    ID              shift and go to state 69
    LITERAL_INT     shift and go to state 71
    LITERAL_REAL    shift and go to state 72
    LITERAL_BOOL    shift and go to state 73
    LITERAL_CHAR    shift and go to state 74
    LITERAL_STRING  shift and go to state 75
    INT             shift and go to state 38
    REAL            shift and go to state 39
    BOOL            shift and go to state 40
    CHAR            shift and go to state 41
    STRING          shift and go to state 42
    ARRAY           shift and go to state 43

    exp                            shift and go to state 153
    call_stmt                      shift and go to state 64
    literal                        shift and go to state 70
    vartype                        shift and go to state 31

state 115

    (91) exp -> + exp .
    (76) exp -> exp . + exp
    (77) exp -> exp . - exp
    (78) exp -> exp . * exp
    (79) exp -> exp . / exp
    (80) exp -> exp . % exp
    (81) exp -> exp . EQ exp
    (82) exp -> exp . NEQ exp
    (83) exp -> exp . LT exp
    (84) exp -> exp . GT exp
    (85) exp -> exp . LEQ exp
    (86) exp -> exp . GEQ exp
    (87) exp -> exp . AND exp
    (88) exp -> exp . OR exp

    THEN            reduce using rule 91 (exp -> + exp .)
    +               reduce using rule 91 (exp -> + exp .)
    -               reduce using rule 91 (exp -> + exp .)
    *               reduce using rule 91 (exp -> + exp .)
    /               reduce using rule 91 (exp -> + exp .)
    %               reduce using rule 91 (exp -> + exp .)
    EQ              reduce using rule 91 (exp -> + exp .)
    NEQ             reduce using rule 91 (exp -> + exp .)
    LT              reduce using rule 91 (exp -> + exp .)
    GT              reduce using rule 91 (exp -> + exp .)
    LEQ             reduce using rule 91 (exp -> + exp .)
    GEQ             reduce using rule 91 (exp -> + exp .)
    AND             reduce using rule 91 (exp -> + exp .)
    OR              reduce using rule 91 (exp -> + exp .)
    DO              reduce using rule 91 (exp -> + exp .)
    OF              reduce using rule 91 (exp -> + exp .)
    )               reduce using rule 91 (exp -> + exp .)
    ,               reduce using rule 91 (exp -> + exp .)
    ]               reduce using rule 91 (exp -> + exp .)
    END             reduce using rule 91 (exp -> + exp .)
    ;               reduce using rule 91 (exp -> + exp .)
    UNTIL           reduce using rule 91 (exp -> + exp .)
    ELSE            reduce using rule 91 (exp -> + exp .)
    DOWNTO          reduce using rule 91 (exp -> + exp .)
    TO              reduce using rule 91 (exp -> + exp .)

  ! +               [ shift and go to state 102 ]
  ! -               [ shift and go to state 103 ]
  ! *               [ shift and go to state 104 ]
  ! /               [ shift and go to state 105 ]
  ! %               [ shift and go to state 106 ]
  ! EQ              [ shift and go to state 107 ]
  ! NEQ             [ shift and go to state 108 ]
  ! LT              [ shift and go to state 109 ]
  ! GT              [ shift and go to state 110 ]
  ! LEQ             [ shift and go to state 111 ]
  ! GEQ             [ shift and go to state 112 ]
  ! AND             [ shift and go to state 113 ]
  ! OR              [ shift and go to state 114 ]


state 116

    (90) exp -> - exp .
    (76) exp -> exp . + exp
    (77) exp -> exp . - exp
    (78) exp -> exp . * exp
    (79) exp -> exp . / exp
    (80) exp -> exp . % exp
    (81) exp -> exp . EQ exp
    (82) exp -> exp . NEQ exp
    (83) exp -> exp . LT exp
    (84) exp -> exp . GT exp
    (85) exp -> exp . LEQ exp
    (86) exp -> exp . GEQ exp
    (87) exp -> exp . AND exp
    (88) exp -> exp . OR exp

    THEN            reduce using rule 90 (exp -> - exp .)
    +               reduce using rule 90 (exp -> - exp .)
    -               reduce using rule 90 (exp -> - exp .)
    *               reduce using rule 90 (exp -> - exp .)
    /               reduce using rule 90 (exp -> - exp .)
    %               reduce using rule 90 (exp -> - exp .)
    EQ              reduce using rule 90 (exp -> - exp .)
    NEQ             reduce using rule 90 (exp -> - exp .)
    LT              reduce using rule 90 (exp -> - exp .)
    GT              reduce using rule 90 (exp -> - exp .)
    LEQ             reduce using rule 90 (exp -> - exp .)
    GEQ             reduce using rule 90 (exp -> - exp .)
    AND             reduce using rule 90 (exp -> - exp .)
    OR              reduce using rule 90 (exp -> - exp .)
    DO              reduce using rule 90 (exp -> - exp .)
    OF              reduce using rule 90 (exp -> - exp .)
    )               reduce using rule 90 (exp -> - exp .)
    ,               reduce using rule 90 (exp -> - exp .)
    ]               reduce using rule 90 (exp -> - exp .)
    END             reduce using rule 90 (exp -> - exp .)
    ;               reduce using rule 90 (exp -> - exp .)
    UNTIL           reduce using rule 90 (exp -> - exp .)
    ELSE            reduce using rule 90 (exp -> - exp .)
    DOWNTO          reduce using rule 90 (exp -> - exp .)
    TO              reduce using rule 90 (exp -> - exp .)

  ! +               [ shift and go to state 102 ]
  ! -               [ shift and go to state 103 ]
  ! *               [ shift and go to state 104 ]
  ! /               [ shift and go to state 105 ]
  ! %               [ shift and go to state 106 ]
  ! EQ              [ shift and go to state 107 ]
  ! NEQ             [ shift and go to state 108 ]
  ! LT              [ shift and go to state 109 ]
  ! GT              [ shift and go to state 110 ]
  ! LEQ             [ shift and go to state 111 ]
  ! GEQ             [ shift and go to state 112 ]
  ! AND             [ shift and go to state 113 ]
  ! OR              [ shift and go to state 114 ]


state 117

    (89) exp -> NOT exp .
    (76) exp -> exp . + exp
    (77) exp -> exp . - exp
    (78) exp -> exp . * exp
    (79) exp -> exp . / exp
    (80) exp -> exp . % exp
    (81) exp -> exp . EQ exp
    (82) exp -> exp . NEQ exp
    (83) exp -> exp . LT exp
    (84) exp -> exp . GT exp
    (85) exp -> exp . LEQ exp
    (86) exp -> exp . GEQ exp
    (87) exp -> exp . AND exp
    (88) exp -> exp . OR exp

    THEN            reduce using rule 89 (exp -> NOT exp .)
    +               reduce using rule 89 (exp -> NOT exp .)
    -               reduce using rule 89 (exp -> NOT exp .)
    *               reduce using rule 89 (exp -> NOT exp .)
    /               reduce using rule 89 (exp -> NOT exp .)
    %               reduce using rule 89 (exp -> NOT exp .)
    EQ              reduce using rule 89 (exp -> NOT exp .)
    NEQ             reduce using rule 89 (exp -> NOT exp .)
    LT              reduce using rule 89 (exp -> NOT exp .)
    GT              reduce using rule 89 (exp -> NOT exp .)
    LEQ             reduce using rule 89 (exp -> NOT exp .)
    GEQ             reduce using rule 89 (exp -> NOT exp .)
    AND             reduce using rule 89 (exp -> NOT exp .)
    OR              reduce using rule 89 (exp -> NOT exp .)
    DO              reduce using rule 89 (exp -> NOT exp .)
    OF              reduce using rule 89 (exp -> NOT exp .)
    )               reduce using rule 89 (exp -> NOT exp .)
    ,               reduce using rule 89 (exp -> NOT exp .)
    ]               reduce using rule 89 (exp -> NOT exp .)
    END             reduce using rule 89 (exp -> NOT exp .)
    ;               reduce using rule 89 (exp -> NOT exp .)
    UNTIL           reduce using rule 89 (exp -> NOT exp .)
    ELSE            reduce using rule 89 (exp -> NOT exp .)
    DOWNTO          reduce using rule 89 (exp -> NOT exp .)
    TO              reduce using rule 89 (exp -> NOT exp .)

  ! +               [ shift and go to state 102 ]
  ! -               [ shift and go to state 103 ]
  ! *               [ shift and go to state 104 ]
  ! /               [ shift and go to state 105 ]
  ! %               [ shift and go to state 106 ]
  ! EQ              [ shift and go to state 107 ]
  ! NEQ             [ shift and go to state 108 ]
  ! LT              [ shift and go to state 109 ]
  ! GT              [ shift and go to state 110 ]
  ! LEQ             [ shift and go to state 111 ]
  ! GEQ             [ shift and go to state 112 ]
  ! AND             [ shift and go to state 113 ]
  ! OR              [ shift and go to state 114 ]


state 118

    (92) exp -> ( exp . )
    (76) exp -> exp . + exp
    (77) exp -> exp . - exp
    (78) exp -> exp . * exp
    (79) exp -> exp . / exp
    (80) exp -> exp . % exp
    (81) exp -> exp . EQ exp
    (82) exp -> exp . NEQ exp
    (83) exp -> exp . LT exp
    (84) exp -> exp . GT exp
    (85) exp -> exp . LEQ exp
    (86) exp -> exp . GEQ exp
    (87) exp -> exp . AND exp
    (88) exp -> exp . OR exp

    )               shift and go to state 154
    +               shift and go to state 102
    -               shift and go to state 103
    *               shift and go to state 104
    /               shift and go to state 105
    %               shift and go to state 106
    EQ              shift and go to state 107
    NEQ             shift and go to state 108
    LT              shift and go to state 109
    GT              shift and go to state 110
    LEQ             shift and go to state 111
    GEQ             shift and go to state 112
    AND             shift and go to state 113
    OR              shift and go to state 114


state 119

    (95) exp -> ID [ . exp ]
    (75) exp -> . call_stmt
    (76) exp -> . exp + exp
    (77) exp -> . exp - exp
    (78) exp -> . exp * exp
    (79) exp -> . exp / exp
    (80) exp -> . exp % exp
    (81) exp -> . exp EQ exp
    (82) exp -> . exp NEQ exp
    (83) exp -> . exp LT exp
    (84) exp -> . exp GT exp
    (85) exp -> . exp LEQ exp
    (86) exp -> . exp GEQ exp
    (87) exp -> . exp AND exp
    (88) exp -> . exp OR exp
    (89) exp -> . NOT exp
    (90) exp -> . - exp
    (91) exp -> . + exp
    (92) exp -> . ( exp )
    (93) exp -> . ID
    (94) exp -> . literal
    (95) exp -> . ID [ exp ]
    (60) call_stmt -> . ID ( exp comma_exp_list )
    (61) call_stmt -> . vartype ( exp )
    (62) call_stmt -> . ID ( )
    (70) literal -> . LITERAL_INT
    (71) literal -> . LITERAL_REAL
    (72) literal -> . LITERAL_BOOL
    (73) literal -> . LITERAL_CHAR
    (74) literal -> . LITERAL_STRING
    (27) vartype -> . INT
    (28) vartype -> . REAL
    (29) vartype -> . BOOL
    (30) vartype -> . CHAR
    (31) vartype -> . STRING
    (32) vartype -> . ARRAY [ LITERAL_INT ] OF vartype
    (33) vartype -> . ARRAY [ LITERAL_INT RANGE LITERAL_INT ] OF vartype

    NOT             shift and go to state 67
    -               shift and go to state 66
    +               shift and go to state 65
    (               shift and go to state 68
    ID              shift and go to state 69
    LITERAL_INT     shift and go to state 71
    LITERAL_REAL    shift and go to state 72
    LITERAL_BOOL    shift and go to state 73
    LITERAL_CHAR    shift and go to state 74
    LITERAL_STRING  shift and go to state 75
    INT             shift and go to state 38
    REAL            shift and go to state 39
    BOOL            shift and go to state 40
    CHAR            shift and go to state 41
    STRING          shift and go to state 42
    ARRAY           shift and go to state 43

    exp                            shift and go to state 155
    call_stmt                      shift and go to state 64
    literal                        shift and go to state 70
    vartype                        shift and go to state 31

state 120

    (51) while_stmt -> WHILE exp DO . stmt
    (36) stmt -> . ID : non_label_stmt
    (37) stmt -> . non_label_stmt
    (38) non_label_stmt -> . assign_stmt
    (39) non_label_stmt -> . call_stmt
    (40) non_label_stmt -> . for_stmt
    (41) non_label_stmt -> . if_stmt
    (42) non_label_stmt -> . while_stmt
    (43) non_label_stmt -> . repeat_stmt
    (44) non_label_stmt -> . case_stmt
    (45) non_label_stmt -> . goto_stmt
    (46) non_label_stmt -> . compound_stmt
    (47) assign_stmt -> . lvalue ASSIGN exp
    (60) call_stmt -> . ID ( exp comma_exp_list )
    (61) call_stmt -> . vartype ( exp )
    (62) call_stmt -> . ID ( )
    (48) for_stmt -> . FOR ID ASSIGN exp direction exp DO stmt
    (65) if_stmt -> . IF exp THEN stmt else_stmt
    (51) while_stmt -> . WHILE exp DO stmt
    (52) repeat_stmt -> . REPEAT stmt semicolon_stmt_list UNTIL exp
    (53) case_stmt -> . CASE exp OF case_exp_list END
    (58) goto_stmt -> . GOTO ID
    (59) compound_stmt -> . BEGIN stmt semicolon_stmt_list END
    (68) lvalue -> . ID
    (69) lvalue -> . ID [ exp ]
    (27) vartype -> . INT
    (28) vartype -> . REAL
    (29) vartype -> . BOOL
    (30) vartype -> . CHAR
    (31) vartype -> . STRING
    (32) vartype -> . ARRAY [ LITERAL_INT ] OF vartype
    (33) vartype -> . ARRAY [ LITERAL_INT RANGE LITERAL_INT ] OF vartype

    ID              shift and go to state 19
    FOR             shift and go to state 32
    IF              shift and go to state 33
    WHILE           shift and go to state 34
    REPEAT          shift and go to state 35
    CASE            shift and go to state 36
    GOTO            shift and go to state 37
    BEGIN           shift and go to state 11
    INT             shift and go to state 38
    REAL            shift and go to state 39
    BOOL            shift and go to state 40
    CHAR            shift and go to state 41
    STRING          shift and go to state 42
    ARRAY           shift and go to state 43

    stmt                           shift and go to state 156
    non_label_stmt                 shift and go to state 20
    assign_stmt                    shift and go to state 21
    call_stmt                      shift and go to state 22
    for_stmt                       shift and go to state 23
    if_stmt                        shift and go to state 24
    while_stmt                     shift and go to state 25
    repeat_stmt                    shift and go to state 26
    case_stmt                      shift and go to state 27
    goto_stmt                      shift and go to state 28
    compound_stmt                  shift and go to state 29
    lvalue                         shift and go to state 30
    vartype                        shift and go to state 31

state 121

    (52) repeat_stmt -> REPEAT stmt semicolon_stmt_list . UNTIL exp
    (34) semicolon_stmt_list -> semicolon_stmt_list . ; stmt

    UNTIL           shift and go to state 157
    ;               shift and go to state 92


state 122

    (53) case_stmt -> CASE exp OF . case_exp_list END
    (54) case_exp_list -> . case_exp_list ; case_exp
    (55) case_exp_list -> . case_exp
    (56) case_exp -> . literal : stmt
    (57) case_exp -> . ID : stmt
    (70) literal -> . LITERAL_INT
    (71) literal -> . LITERAL_REAL
    (72) literal -> . LITERAL_BOOL
    (73) literal -> . LITERAL_CHAR
    (74) literal -> . LITERAL_STRING

    ID              shift and go to state 161
    LITERAL_INT     shift and go to state 71
    LITERAL_REAL    shift and go to state 72
    LITERAL_BOOL    shift and go to state 73
    LITERAL_CHAR    shift and go to state 74
    LITERAL_STRING  shift and go to state 75

    case_exp_list                  shift and go to state 158
    case_exp                       shift and go to state 159
    literal                        shift and go to state 160

state 123

    (32) vartype -> ARRAY [ LITERAL_INT . ] OF vartype
    (33) vartype -> ARRAY [ LITERAL_INT . RANGE LITERAL_INT ] OF vartype

    ]               shift and go to state 162
    RANGE           shift and go to state 163


state 124

    (11) var -> id_list : vartype . ;
    (12) var -> id_list : vartype . EQ exp ;

    ;               shift and go to state 164
    EQ              shift and go to state 165


state 125

    (17) comma_id_list -> comma_id_list , . ID

    ID              shift and go to state 166


state 126

    (15) const_exp -> id_list EQ literal . ;

    ;               shift and go to state 167


state 127

    (8) local -> header ; body ; .

    BEGIN           reduce using rule 8 (local -> header ; body ; .)
    VAR             reduce using rule 8 (local -> header ; body ; .)
    LABEL           reduce using rule 8 (local -> header ; body ; .)
    CONST           reduce using rule 8 (local -> header ; body ; .)
    PROCEDURE       reduce using rule 8 (local -> header ; body ; .)
    FUNCTION        reduce using rule 8 (local -> header ; body ; .)


state 128

    (19) header -> PROCEDURE ID ( formal_list . )

    )               shift and go to state 168


state 129

    (20) header -> PROCEDURE ID ( ) .

    ;               reduce using rule 20 (header -> PROCEDURE ID ( ) .)


state 130

    (23) formal_list -> formal . semicolon_formal_list
    (25) semicolon_formal_list -> . semicolon_formal_list ; formal
    (26) semicolon_formal_list -> . empty
    (96) empty -> .

    ;               reduce using rule 96 (empty -> .)
    )               reduce using rule 96 (empty -> .)

    semicolon_formal_list          shift and go to state 169
    empty                          shift and go to state 170

state 131

    (24) formal -> id_list . : vartype

    :               shift and go to state 171


state 132

    (21) header -> FUNCTION ID ( formal_list . ) : vartype

    )               shift and go to state 172


state 133

    (22) header -> FUNCTION ID ( ) . : vartype

    :               shift and go to state 173


state 134

    (34) semicolon_stmt_list -> semicolon_stmt_list ; stmt .

    END             reduce using rule 34 (semicolon_stmt_list -> semicolon_stmt_list ; stmt .)
    ;               reduce using rule 34 (semicolon_stmt_list -> semicolon_stmt_list ; stmt .)
    UNTIL           reduce using rule 34 (semicolon_stmt_list -> semicolon_stmt_list ; stmt .)


state 135

    (60) call_stmt -> ID ( exp comma_exp_list . )
    (63) comma_exp_list -> comma_exp_list . , exp

    )               shift and go to state 174
    ,               shift and go to state 175


state 136

    (64) comma_exp_list -> empty .

    )               reduce using rule 64 (comma_exp_list -> empty .)
    ,               reduce using rule 64 (comma_exp_list -> empty .)


state 137

    (69) lvalue -> ID [ exp ] .

    ASSIGN          reduce using rule 69 (lvalue -> ID [ exp ] .)


state 138

    (61) call_stmt -> vartype ( exp ) .

    END             reduce using rule 61 (call_stmt -> vartype ( exp ) .)
    ;               reduce using rule 61 (call_stmt -> vartype ( exp ) .)
    THEN            reduce using rule 61 (call_stmt -> vartype ( exp ) .)
    +               reduce using rule 61 (call_stmt -> vartype ( exp ) .)
    -               reduce using rule 61 (call_stmt -> vartype ( exp ) .)
    *               reduce using rule 61 (call_stmt -> vartype ( exp ) .)
    /               reduce using rule 61 (call_stmt -> vartype ( exp ) .)
    %               reduce using rule 61 (call_stmt -> vartype ( exp ) .)
    EQ              reduce using rule 61 (call_stmt -> vartype ( exp ) .)
    NEQ             reduce using rule 61 (call_stmt -> vartype ( exp ) .)
    LT              reduce using rule 61 (call_stmt -> vartype ( exp ) .)
    GT              reduce using rule 61 (call_stmt -> vartype ( exp ) .)
    LEQ             reduce using rule 61 (call_stmt -> vartype ( exp ) .)
    GEQ             reduce using rule 61 (call_stmt -> vartype ( exp ) .)
    AND             reduce using rule 61 (call_stmt -> vartype ( exp ) .)
    OR              reduce using rule 61 (call_stmt -> vartype ( exp ) .)
    DO              reduce using rule 61 (call_stmt -> vartype ( exp ) .)
    UNTIL           reduce using rule 61 (call_stmt -> vartype ( exp ) .)
    OF              reduce using rule 61 (call_stmt -> vartype ( exp ) .)
    ELSE            reduce using rule 61 (call_stmt -> vartype ( exp ) .)
    )               reduce using rule 61 (call_stmt -> vartype ( exp ) .)
    ,               reduce using rule 61 (call_stmt -> vartype ( exp ) .)
    ]               reduce using rule 61 (call_stmt -> vartype ( exp ) .)
    DOWNTO          reduce using rule 61 (call_stmt -> vartype ( exp ) .)
    TO              reduce using rule 61 (call_stmt -> vartype ( exp ) .)


state 139

    (48) for_stmt -> FOR ID ASSIGN exp . direction exp DO stmt
    (76) exp -> exp . + exp
    (77) exp -> exp . - exp
    (78) exp -> exp . * exp
    (79) exp -> exp . / exp
    (80) exp -> exp . % exp
    (81) exp -> exp . EQ exp
    (82) exp -> exp . NEQ exp
    (83) exp -> exp . LT exp
    (84) exp -> exp . GT exp
    (85) exp -> exp . LEQ exp
    (86) exp -> exp . GEQ exp
    (87) exp -> exp . AND exp
    (88) exp -> exp . OR exp
    (49) direction -> . DOWNTO
    (50) direction -> . TO

    +               shift and go to state 102
    -               shift and go to state 103
    *               shift and go to state 104
    /               shift and go to state 105
    %               shift and go to state 106
    EQ              shift and go to state 107
    NEQ             shift and go to state 108
    LT              shift and go to state 109
    GT              shift and go to state 110
    LEQ             shift and go to state 111
    GEQ             shift and go to state 112
    AND             shift and go to state 113
    OR              shift and go to state 114
    DOWNTO          shift and go to state 177
    TO              shift and go to state 178

    direction                      shift and go to state 176

state 140

    (65) if_stmt -> IF exp THEN stmt . else_stmt
    (66) else_stmt -> . ELSE stmt
    (67) else_stmt -> . empty
    (96) empty -> .

  ! shift/reduce conflict for ELSE resolved as shift
    ELSE            shift and go to state 180
    END             reduce using rule 96 (empty -> .)
    ;               reduce using rule 96 (empty -> .)
    UNTIL           reduce using rule 96 (empty -> .)

  ! ELSE            [ reduce using rule 96 (empty -> .) ]

    else_stmt                      shift and go to state 179
    empty                          shift and go to state 181

state 141

    (76) exp -> exp + exp .
    (76) exp -> exp . + exp
    (77) exp -> exp . - exp
    (78) exp -> exp . * exp
    (79) exp -> exp . / exp
    (80) exp -> exp . % exp
    (81) exp -> exp . EQ exp
    (82) exp -> exp . NEQ exp
    (83) exp -> exp . LT exp
    (84) exp -> exp . GT exp
    (85) exp -> exp . LEQ exp
    (86) exp -> exp . GEQ exp
    (87) exp -> exp . AND exp
    (88) exp -> exp . OR exp

    THEN            reduce using rule 76 (exp -> exp + exp .)
    +               reduce using rule 76 (exp -> exp + exp .)
    -               reduce using rule 76 (exp -> exp + exp .)
    EQ              reduce using rule 76 (exp -> exp + exp .)
    NEQ             reduce using rule 76 (exp -> exp + exp .)
    LT              reduce using rule 76 (exp -> exp + exp .)
    GT              reduce using rule 76 (exp -> exp + exp .)
    LEQ             reduce using rule 76 (exp -> exp + exp .)
    GEQ             reduce using rule 76 (exp -> exp + exp .)
    AND             reduce using rule 76 (exp -> exp + exp .)
    OR              reduce using rule 76 (exp -> exp + exp .)
    DO              reduce using rule 76 (exp -> exp + exp .)
    OF              reduce using rule 76 (exp -> exp + exp .)
    )               reduce using rule 76 (exp -> exp + exp .)
    ,               reduce using rule 76 (exp -> exp + exp .)
    ]               reduce using rule 76 (exp -> exp + exp .)
    END             reduce using rule 76 (exp -> exp + exp .)
    ;               reduce using rule 76 (exp -> exp + exp .)
    UNTIL           reduce using rule 76 (exp -> exp + exp .)
    ELSE            reduce using rule 76 (exp -> exp + exp .)
    DOWNTO          reduce using rule 76 (exp -> exp + exp .)
    TO              reduce using rule 76 (exp -> exp + exp .)
    *               shift and go to state 104
    /               shift and go to state 105
    %               shift and go to state 106

  ! *               [ reduce using rule 76 (exp -> exp + exp .) ]
  ! /               [ reduce using rule 76 (exp -> exp + exp .) ]
  ! %               [ reduce using rule 76 (exp -> exp + exp .) ]
  ! +               [ shift and go to state 102 ]
  ! -               [ shift and go to state 103 ]
  ! EQ              [ shift and go to state 107 ]
  ! NEQ             [ shift and go to state 108 ]
  ! LT              [ shift and go to state 109 ]
  ! GT              [ shift and go to state 110 ]
  ! LEQ             [ shift and go to state 111 ]
  ! GEQ             [ shift and go to state 112 ]
  ! AND             [ shift and go to state 113 ]
  ! OR              [ shift and go to state 114 ]


state 142

    (77) exp -> exp - exp .
    (76) exp -> exp . + exp
    (77) exp -> exp . - exp
    (78) exp -> exp . * exp
    (79) exp -> exp . / exp
    (80) exp -> exp . % exp
    (81) exp -> exp . EQ exp
    (82) exp -> exp . NEQ exp
    (83) exp -> exp . LT exp
    (84) exp -> exp . GT exp
    (85) exp -> exp . LEQ exp
    (86) exp -> exp . GEQ exp
    (87) exp -> exp . AND exp
    (88) exp -> exp . OR exp

    THEN            reduce using rule 77 (exp -> exp - exp .)
    +               reduce using rule 77 (exp -> exp - exp .)
    -               reduce using rule 77 (exp -> exp - exp .)
    EQ              reduce using rule 77 (exp -> exp - exp .)
    NEQ             reduce using rule 77 (exp -> exp - exp .)
    LT              reduce using rule 77 (exp -> exp - exp .)
    GT              reduce using rule 77 (exp -> exp - exp .)
    LEQ             reduce using rule 77 (exp -> exp - exp .)
    GEQ             reduce using rule 77 (exp -> exp - exp .)
    AND             reduce using rule 77 (exp -> exp - exp .)
    OR              reduce using rule 77 (exp -> exp - exp .)
    DO              reduce using rule 77 (exp -> exp - exp .)
    OF              reduce using rule 77 (exp -> exp - exp .)
    )               reduce using rule 77 (exp -> exp - exp .)
    ,               reduce using rule 77 (exp -> exp - exp .)
    ]               reduce using rule 77 (exp -> exp - exp .)
    END             reduce using rule 77 (exp -> exp - exp .)
    ;               reduce using rule 77 (exp -> exp - exp .)
    UNTIL           reduce using rule 77 (exp -> exp - exp .)
    ELSE            reduce using rule 77 (exp -> exp - exp .)
    DOWNTO          reduce using rule 77 (exp -> exp - exp .)
    TO              reduce using rule 77 (exp -> exp - exp .)
    *               shift and go to state 104
    /               shift and go to state 105
    %               shift and go to state 106

  ! *               [ reduce using rule 77 (exp -> exp - exp .) ]
  ! /               [ reduce using rule 77 (exp -> exp - exp .) ]
  ! %               [ reduce using rule 77 (exp -> exp - exp .) ]
  ! +               [ shift and go to state 102 ]
  ! -               [ shift and go to state 103 ]
  ! EQ              [ shift and go to state 107 ]
  ! NEQ             [ shift and go to state 108 ]
  ! LT              [ shift and go to state 109 ]
  ! GT              [ shift and go to state 110 ]
  ! LEQ             [ shift and go to state 111 ]
  ! GEQ             [ shift and go to state 112 ]
  ! AND             [ shift and go to state 113 ]
  ! OR              [ shift and go to state 114 ]


state 143

    (78) exp -> exp * exp .
    (76) exp -> exp . + exp
    (77) exp -> exp . - exp
    (78) exp -> exp . * exp
    (79) exp -> exp . / exp
    (80) exp -> exp . % exp
    (81) exp -> exp . EQ exp
    (82) exp -> exp . NEQ exp
    (83) exp -> exp . LT exp
    (84) exp -> exp . GT exp
    (85) exp -> exp . LEQ exp
    (86) exp -> exp . GEQ exp
    (87) exp -> exp . AND exp
    (88) exp -> exp . OR exp

    THEN            reduce using rule 78 (exp -> exp * exp .)
    +               reduce using rule 78 (exp -> exp * exp .)
    -               reduce using rule 78 (exp -> exp * exp .)
    *               reduce using rule 78 (exp -> exp * exp .)
    /               reduce using rule 78 (exp -> exp * exp .)
    %               reduce using rule 78 (exp -> exp * exp .)
    EQ              reduce using rule 78 (exp -> exp * exp .)
    NEQ             reduce using rule 78 (exp -> exp * exp .)
    LT              reduce using rule 78 (exp -> exp * exp .)
    GT              reduce using rule 78 (exp -> exp * exp .)
    LEQ             reduce using rule 78 (exp -> exp * exp .)
    GEQ             reduce using rule 78 (exp -> exp * exp .)
    AND             reduce using rule 78 (exp -> exp * exp .)
    OR              reduce using rule 78 (exp -> exp * exp .)
    DO              reduce using rule 78 (exp -> exp * exp .)
    OF              reduce using rule 78 (exp -> exp * exp .)
    )               reduce using rule 78 (exp -> exp * exp .)
    ,               reduce using rule 78 (exp -> exp * exp .)
    ]               reduce using rule 78 (exp -> exp * exp .)
    END             reduce using rule 78 (exp -> exp * exp .)
    ;               reduce using rule 78 (exp -> exp * exp .)
    UNTIL           reduce using rule 78 (exp -> exp * exp .)
    ELSE            reduce using rule 78 (exp -> exp * exp .)
    DOWNTO          reduce using rule 78 (exp -> exp * exp .)
    TO              reduce using rule 78 (exp -> exp * exp .)

  ! +               [ shift and go to state 102 ]
  ! -               [ shift and go to state 103 ]
  ! *               [ shift and go to state 104 ]
  ! /               [ shift and go to state 105 ]
  ! %               [ shift and go to state 106 ]
  ! EQ              [ shift and go to state 107 ]
  ! NEQ             [ shift and go to state 108 ]
  ! LT              [ shift and go to state 109 ]
  ! GT              [ shift and go to state 110 ]
  ! LEQ             [ shift and go to state 111 ]
  ! GEQ             [ shift and go to state 112 ]
  ! AND             [ shift and go to state 113 ]
  ! OR              [ shift and go to state 114 ]


state 144

    (79) exp -> exp / exp .
    (76) exp -> exp . + exp
    (77) exp -> exp . - exp
    (78) exp -> exp . * exp
    (79) exp -> exp . / exp
    (80) exp -> exp . % exp
    (81) exp -> exp . EQ exp
    (82) exp -> exp . NEQ exp
    (83) exp -> exp . LT exp
    (84) exp -> exp . GT exp
    (85) exp -> exp . LEQ exp
    (86) exp -> exp . GEQ exp
    (87) exp -> exp . AND exp
    (88) exp -> exp . OR exp

    THEN            reduce using rule 79 (exp -> exp / exp .)
    +               reduce using rule 79 (exp -> exp / exp .)
    -               reduce using rule 79 (exp -> exp / exp .)
    *               reduce using rule 79 (exp -> exp / exp .)
    /               reduce using rule 79 (exp -> exp / exp .)
    %               reduce using rule 79 (exp -> exp / exp .)
    EQ              reduce using rule 79 (exp -> exp / exp .)
    NEQ             reduce using rule 79 (exp -> exp / exp .)
    LT              reduce using rule 79 (exp -> exp / exp .)
    GT              reduce using rule 79 (exp -> exp / exp .)
    LEQ             reduce using rule 79 (exp -> exp / exp .)
    GEQ             reduce using rule 79 (exp -> exp / exp .)
    AND             reduce using rule 79 (exp -> exp / exp .)
    OR              reduce using rule 79 (exp -> exp / exp .)
    DO              reduce using rule 79 (exp -> exp / exp .)
    OF              reduce using rule 79 (exp -> exp / exp .)
    )               reduce using rule 79 (exp -> exp / exp .)
    ,               reduce using rule 79 (exp -> exp / exp .)
    ]               reduce using rule 79 (exp -> exp / exp .)
    END             reduce using rule 79 (exp -> exp / exp .)
    ;               reduce using rule 79 (exp -> exp / exp .)
    UNTIL           reduce using rule 79 (exp -> exp / exp .)
    ELSE            reduce using rule 79 (exp -> exp / exp .)
    DOWNTO          reduce using rule 79 (exp -> exp / exp .)
    TO              reduce using rule 79 (exp -> exp / exp .)

  ! +               [ shift and go to state 102 ]
  ! -               [ shift and go to state 103 ]
  ! *               [ shift and go to state 104 ]
  ! /               [ shift and go to state 105 ]
  ! %               [ shift and go to state 106 ]
  ! EQ              [ shift and go to state 107 ]
  ! NEQ             [ shift and go to state 108 ]
  ! LT              [ shift and go to state 109 ]
  ! GT              [ shift and go to state 110 ]
  ! LEQ             [ shift and go to state 111 ]
  ! GEQ             [ shift and go to state 112 ]
  ! AND             [ shift and go to state 113 ]
  ! OR              [ shift and go to state 114 ]


state 145

    (80) exp -> exp % exp .
    (76) exp -> exp . + exp
    (77) exp -> exp . - exp
    (78) exp -> exp . * exp
    (79) exp -> exp . / exp
    (80) exp -> exp . % exp
    (81) exp -> exp . EQ exp
    (82) exp -> exp . NEQ exp
    (83) exp -> exp . LT exp
    (84) exp -> exp . GT exp
    (85) exp -> exp . LEQ exp
    (86) exp -> exp . GEQ exp
    (87) exp -> exp . AND exp
    (88) exp -> exp . OR exp

    THEN            reduce using rule 80 (exp -> exp % exp .)
    +               reduce using rule 80 (exp -> exp % exp .)
    -               reduce using rule 80 (exp -> exp % exp .)
    *               reduce using rule 80 (exp -> exp % exp .)
    /               reduce using rule 80 (exp -> exp % exp .)
    %               reduce using rule 80 (exp -> exp % exp .)
    EQ              reduce using rule 80 (exp -> exp % exp .)
    NEQ             reduce using rule 80 (exp -> exp % exp .)
    LT              reduce using rule 80 (exp -> exp % exp .)
    GT              reduce using rule 80 (exp -> exp % exp .)
    LEQ             reduce using rule 80 (exp -> exp % exp .)
    GEQ             reduce using rule 80 (exp -> exp % exp .)
    AND             reduce using rule 80 (exp -> exp % exp .)
    OR              reduce using rule 80 (exp -> exp % exp .)
    DO              reduce using rule 80 (exp -> exp % exp .)
    OF              reduce using rule 80 (exp -> exp % exp .)
    )               reduce using rule 80 (exp -> exp % exp .)
    ,               reduce using rule 80 (exp -> exp % exp .)
    ]               reduce using rule 80 (exp -> exp % exp .)
    END             reduce using rule 80 (exp -> exp % exp .)
    ;               reduce using rule 80 (exp -> exp % exp .)
    UNTIL           reduce using rule 80 (exp -> exp % exp .)
    ELSE            reduce using rule 80 (exp -> exp % exp .)
    DOWNTO          reduce using rule 80 (exp -> exp % exp .)
    TO              reduce using rule 80 (exp -> exp % exp .)

  ! +               [ shift and go to state 102 ]
  ! -               [ shift and go to state 103 ]
  ! *               [ shift and go to state 104 ]
  ! /               [ shift and go to state 105 ]
  ! %               [ shift and go to state 106 ]
  ! EQ              [ shift and go to state 107 ]
  ! NEQ             [ shift and go to state 108 ]
  ! LT              [ shift and go to state 109 ]
  ! GT              [ shift and go to state 110 ]
  ! LEQ             [ shift and go to state 111 ]
  ! GEQ             [ shift and go to state 112 ]
  ! AND             [ shift and go to state 113 ]
  ! OR              [ shift and go to state 114 ]


state 146

    (81) exp -> exp EQ exp .
    (76) exp -> exp . + exp
    (77) exp -> exp . - exp
    (78) exp -> exp . * exp
    (79) exp -> exp . / exp
    (80) exp -> exp . % exp
    (81) exp -> exp . EQ exp
    (82) exp -> exp . NEQ exp
    (83) exp -> exp . LT exp
    (84) exp -> exp . GT exp
    (85) exp -> exp . LEQ exp
    (86) exp -> exp . GEQ exp
    (87) exp -> exp . AND exp
    (88) exp -> exp . OR exp

    THEN            reduce using rule 81 (exp -> exp EQ exp .)
    EQ              reduce using rule 81 (exp -> exp EQ exp .)
    NEQ             reduce using rule 81 (exp -> exp EQ exp .)
    AND             reduce using rule 81 (exp -> exp EQ exp .)
    OR              reduce using rule 81 (exp -> exp EQ exp .)
    DO              reduce using rule 81 (exp -> exp EQ exp .)
    OF              reduce using rule 81 (exp -> exp EQ exp .)
    )               reduce using rule 81 (exp -> exp EQ exp .)
    ,               reduce using rule 81 (exp -> exp EQ exp .)
    ]               reduce using rule 81 (exp -> exp EQ exp .)
    END             reduce using rule 81 (exp -> exp EQ exp .)
    ;               reduce using rule 81 (exp -> exp EQ exp .)
    UNTIL           reduce using rule 81 (exp -> exp EQ exp .)
    ELSE            reduce using rule 81 (exp -> exp EQ exp .)
    DOWNTO          reduce using rule 81 (exp -> exp EQ exp .)
    TO              reduce using rule 81 (exp -> exp EQ exp .)
    +               shift and go to state 102
    -               shift and go to state 103
    *               shift and go to state 104
    /               shift and go to state 105
    %               shift and go to state 106
    LT              shift and go to state 109
    GT              shift and go to state 110
    LEQ             shift and go to state 111
    GEQ             shift and go to state 112

  ! +               [ reduce using rule 81 (exp -> exp EQ exp .) ]
  ! -               [ reduce using rule 81 (exp -> exp EQ exp .) ]
  ! *               [ reduce using rule 81 (exp -> exp EQ exp .) ]
  ! /               [ reduce using rule 81 (exp -> exp EQ exp .) ]
  ! %               [ reduce using rule 81 (exp -> exp EQ exp .) ]
  ! LT              [ reduce using rule 81 (exp -> exp EQ exp .) ]
  ! GT              [ reduce using rule 81 (exp -> exp EQ exp .) ]
  ! LEQ             [ reduce using rule 81 (exp -> exp EQ exp .) ]
  ! GEQ             [ reduce using rule 81 (exp -> exp EQ exp .) ]
  ! EQ              [ shift and go to state 107 ]
  ! NEQ             [ shift and go to state 108 ]
  ! AND             [ shift and go to state 113 ]
  ! OR              [ shift and go to state 114 ]


state 147

    (82) exp -> exp NEQ exp .
    (76) exp -> exp . + exp
    (77) exp -> exp . - exp
    (78) exp -> exp . * exp
    (79) exp -> exp . / exp
    (80) exp -> exp . % exp
    (81) exp -> exp . EQ exp
    (82) exp -> exp . NEQ exp
    (83) exp -> exp . LT exp
    (84) exp -> exp . GT exp
    (85) exp -> exp . LEQ exp
    (86) exp -> exp . GEQ exp
    (87) exp -> exp . AND exp
    (88) exp -> exp . OR exp

    THEN            reduce using rule 82 (exp -> exp NEQ exp .)
    EQ              reduce using rule 82 (exp -> exp NEQ exp .)
    NEQ             reduce using rule 82 (exp -> exp NEQ exp .)
    AND             reduce using rule 82 (exp -> exp NEQ exp .)
    OR              reduce using rule 82 (exp -> exp NEQ exp .)
    DO              reduce using rule 82 (exp -> exp NEQ exp .)
    OF              reduce using rule 82 (exp -> exp NEQ exp .)
    )               reduce using rule 82 (exp -> exp NEQ exp .)
    ,               reduce using rule 82 (exp -> exp NEQ exp .)
    ]               reduce using rule 82 (exp -> exp NEQ exp .)
    END             reduce using rule 82 (exp -> exp NEQ exp .)
    ;               reduce using rule 82 (exp -> exp NEQ exp .)
    UNTIL           reduce using rule 82 (exp -> exp NEQ exp .)
    ELSE            reduce using rule 82 (exp -> exp NEQ exp .)
    DOWNTO          reduce using rule 82 (exp -> exp NEQ exp .)
    TO              reduce using rule 82 (exp -> exp NEQ exp .)
    +               shift and go to state 102
    -               shift and go to state 103
    *               shift and go to state 104
    /               shift and go to state 105
    %               shift and go to state 106
    LT              shift and go to state 109
    GT              shift and go to state 110
    LEQ             shift and go to state 111
    GEQ             shift and go to state 112

  ! +               [ reduce using rule 82 (exp -> exp NEQ exp .) ]
  ! -               [ reduce using rule 82 (exp -> exp NEQ exp .) ]
  ! *               [ reduce using rule 82 (exp -> exp NEQ exp .) ]
  ! /               [ reduce using rule 82 (exp -> exp NEQ exp .) ]
  ! %               [ reduce using rule 82 (exp -> exp NEQ exp .) ]
  ! LT              [ reduce using rule 82 (exp -> exp NEQ exp .) ]
  ! GT              [ reduce using rule 82 (exp -> exp NEQ exp .) ]
  ! LEQ             [ reduce using rule 82 (exp -> exp NEQ exp .) ]
  ! GEQ             [ reduce using rule 82 (exp -> exp NEQ exp .) ]
  ! EQ              [ shift and go to state 107 ]
  ! NEQ             [ shift and go to state 108 ]
  ! AND             [ shift and go to state 113 ]
  ! OR              [ shift and go to state 114 ]


state 148

    (83) exp -> exp LT exp .
    (76) exp -> exp . + exp
    (77) exp -> exp . - exp
    (78) exp -> exp . * exp
    (79) exp -> exp . / exp
    (80) exp -> exp . % exp
    (81) exp -> exp . EQ exp
    (82) exp -> exp . NEQ exp
    (83) exp -> exp . LT exp
    (84) exp -> exp . GT exp
    (85) exp -> exp . LEQ exp
    (86) exp -> exp . GEQ exp
    (87) exp -> exp . AND exp
    (88) exp -> exp . OR exp

    THEN            reduce using rule 83 (exp -> exp LT exp .)
    EQ              reduce using rule 83 (exp -> exp LT exp .)
    NEQ             reduce using rule 83 (exp -> exp LT exp .)
    LT              reduce using rule 83 (exp -> exp LT exp .)
    GT              reduce using rule 83 (exp -> exp LT exp .)
    LEQ             reduce using rule 83 (exp -> exp LT exp .)
    GEQ             reduce using rule 83 (exp -> exp LT exp .)
    AND             reduce using rule 83 (exp -> exp LT exp .)
    OR              reduce using rule 83 (exp -> exp LT exp .)
    DO              reduce using rule 83 (exp -> exp LT exp .)
    OF              reduce using rule 83 (exp -> exp LT exp .)
    )               reduce using rule 83 (exp -> exp LT exp .)
    ,               reduce using rule 83 (exp -> exp LT exp .)
    ]               reduce using rule 83 (exp -> exp LT exp .)
    END             reduce using rule 83 (exp -> exp LT exp .)
    ;               reduce using rule 83 (exp -> exp LT exp .)
    UNTIL           reduce using rule 83 (exp -> exp LT exp .)
    ELSE            reduce using rule 83 (exp -> exp LT exp .)
    DOWNTO          reduce using rule 83 (exp -> exp LT exp .)
    TO              reduce using rule 83 (exp -> exp LT exp .)
    +               shift and go to state 102
    -               shift and go to state 103
    *               shift and go to state 104
    /               shift and go to state 105
    %               shift and go to state 106

  ! +               [ reduce using rule 83 (exp -> exp LT exp .) ]
  ! -               [ reduce using rule 83 (exp -> exp LT exp .) ]
  ! *               [ reduce using rule 83 (exp -> exp LT exp .) ]
  ! /               [ reduce using rule 83 (exp -> exp LT exp .) ]
  ! %               [ reduce using rule 83 (exp -> exp LT exp .) ]
  ! EQ              [ shift and go to state 107 ]
  ! NEQ             [ shift and go to state 108 ]
  ! LT              [ shift and go to state 109 ]
  ! GT              [ shift and go to state 110 ]
  ! LEQ             [ shift and go to state 111 ]
  ! GEQ             [ shift and go to state 112 ]
  ! AND             [ shift and go to state 113 ]
  ! OR              [ shift and go to state 114 ]


state 149

    (84) exp -> exp GT exp .
    (76) exp -> exp . + exp
    (77) exp -> exp . - exp
    (78) exp -> exp . * exp
    (79) exp -> exp . / exp
    (80) exp -> exp . % exp
    (81) exp -> exp . EQ exp
    (82) exp -> exp . NEQ exp
    (83) exp -> exp . LT exp
    (84) exp -> exp . GT exp
    (85) exp -> exp . LEQ exp
    (86) exp -> exp . GEQ exp
    (87) exp -> exp . AND exp
    (88) exp -> exp . OR exp

    THEN            reduce using rule 84 (exp -> exp GT exp .)
    EQ              reduce using rule 84 (exp -> exp GT exp .)
    NEQ             reduce using rule 84 (exp -> exp GT exp .)
    LT              reduce using rule 84 (exp -> exp GT exp .)
    GT              reduce using rule 84 (exp -> exp GT exp .)
    LEQ             reduce using rule 84 (exp -> exp GT exp .)
    GEQ             reduce using rule 84 (exp -> exp GT exp .)
    AND             reduce using rule 84 (exp -> exp GT exp .)
    OR              reduce using rule 84 (exp -> exp GT exp .)
    DO              reduce using rule 84 (exp -> exp GT exp .)
    OF              reduce using rule 84 (exp -> exp GT exp .)
    )               reduce using rule 84 (exp -> exp GT exp .)
    ,               reduce using rule 84 (exp -> exp GT exp .)
    ]               reduce using rule 84 (exp -> exp GT exp .)
    END             reduce using rule 84 (exp -> exp GT exp .)
    ;               reduce using rule 84 (exp -> exp GT exp .)
    UNTIL           reduce using rule 84 (exp -> exp GT exp .)
    ELSE            reduce using rule 84 (exp -> exp GT exp .)
    DOWNTO          reduce using rule 84 (exp -> exp GT exp .)
    TO              reduce using rule 84 (exp -> exp GT exp .)
    +               shift and go to state 102
    -               shift and go to state 103
    *               shift and go to state 104
    /               shift and go to state 105
    %               shift and go to state 106

  ! +               [ reduce using rule 84 (exp -> exp GT exp .) ]
  ! -               [ reduce using rule 84 (exp -> exp GT exp .) ]
  ! *               [ reduce using rule 84 (exp -> exp GT exp .) ]
  ! /               [ reduce using rule 84 (exp -> exp GT exp .) ]
  ! %               [ reduce using rule 84 (exp -> exp GT exp .) ]
  ! EQ              [ shift and go to state 107 ]
  ! NEQ             [ shift and go to state 108 ]
  ! LT              [ shift and go to state 109 ]
  ! GT              [ shift and go to state 110 ]
  ! LEQ             [ shift and go to state 111 ]
  ! GEQ             [ shift and go to state 112 ]
  ! AND             [ shift and go to state 113 ]
  ! OR              [ shift and go to state 114 ]


state 150

    (85) exp -> exp LEQ exp .
    (76) exp -> exp . + exp
    (77) exp -> exp . - exp
    (78) exp -> exp . * exp
    (79) exp -> exp . / exp
    (80) exp -> exp . % exp
    (81) exp -> exp . EQ exp
    (82) exp -> exp . NEQ exp
    (83) exp -> exp . LT exp
    (84) exp -> exp . GT exp
    (85) exp -> exp . LEQ exp
    (86) exp -> exp . GEQ exp
    (87) exp -> exp . AND exp
    (88) exp -> exp . OR exp

    THEN            reduce using rule 85 (exp -> exp LEQ exp .)
    EQ              reduce using rule 85 (exp -> exp LEQ exp .)
    NEQ             reduce using rule 85 (exp -> exp LEQ exp .)
    LT              reduce using rule 85 (exp -> exp LEQ exp .)
    GT              reduce using rule 85 (exp -> exp LEQ exp .)
    LEQ             reduce using rule 85 (exp -> exp LEQ exp .)
    GEQ             reduce using rule 85 (exp -> exp LEQ exp .)
    AND             reduce using rule 85 (exp -> exp LEQ exp .)
    OR              reduce using rule 85 (exp -> exp LEQ exp .)
    DO              reduce using rule 85 (exp -> exp LEQ exp .)
    OF              reduce using rule 85 (exp -> exp LEQ exp .)
    )               reduce using rule 85 (exp -> exp LEQ exp .)
    ,               reduce using rule 85 (exp -> exp LEQ exp .)
    ]               reduce using rule 85 (exp -> exp LEQ exp .)
    END             reduce using rule 85 (exp -> exp LEQ exp .)
    ;               reduce using rule 85 (exp -> exp LEQ exp .)
    UNTIL           reduce using rule 85 (exp -> exp LEQ exp .)
    ELSE            reduce using rule 85 (exp -> exp LEQ exp .)
    DOWNTO          reduce using rule 85 (exp -> exp LEQ exp .)
    TO              reduce using rule 85 (exp -> exp LEQ exp .)
    +               shift and go to state 102
    -               shift and go to state 103
    *               shift and go to state 104
    /               shift and go to state 105
    %               shift and go to state 106

  ! +               [ reduce using rule 85 (exp -> exp LEQ exp .) ]
  ! -               [ reduce using rule 85 (exp -> exp LEQ exp .) ]
  ! *               [ reduce using rule 85 (exp -> exp LEQ exp .) ]
  ! /               [ reduce using rule 85 (exp -> exp LEQ exp .) ]
  ! %               [ reduce using rule 85 (exp -> exp LEQ exp .) ]
  ! EQ              [ shift and go to state 107 ]
  ! NEQ             [ shift and go to state 108 ]
  ! LT              [ shift and go to state 109 ]
  ! GT              [ shift and go to state 110 ]
  ! LEQ             [ shift and go to state 111 ]
  ! GEQ             [ shift and go to state 112 ]
  ! AND             [ shift and go to state 113 ]
  ! OR              [ shift and go to state 114 ]


state 151

    (86) exp -> exp GEQ exp .
    (76) exp -> exp . + exp
    (77) exp -> exp . - exp
    (78) exp -> exp . * exp
    (79) exp -> exp . / exp
    (80) exp -> exp . % exp
    (81) exp -> exp . EQ exp
    (82) exp -> exp . NEQ exp
    (83) exp -> exp . LT exp
    (84) exp -> exp . GT exp
    (85) exp -> exp . LEQ exp
    (86) exp -> exp . GEQ exp
    (87) exp -> exp . AND exp
    (88) exp -> exp . OR exp

    THEN            reduce using rule 86 (exp -> exp GEQ exp .)
    EQ              reduce using rule 86 (exp -> exp GEQ exp .)
    NEQ             reduce using rule 86 (exp -> exp GEQ exp .)
    LT              reduce using rule 86 (exp -> exp GEQ exp .)
    GT              reduce using rule 86 (exp -> exp GEQ exp .)
    LEQ             reduce using rule 86 (exp -> exp GEQ exp .)
    GEQ             reduce using rule 86 (exp -> exp GEQ exp .)
    AND             reduce using rule 86 (exp -> exp GEQ exp .)
    OR              reduce using rule 86 (exp -> exp GEQ exp .)
    DO              reduce using rule 86 (exp -> exp GEQ exp .)
    OF              reduce using rule 86 (exp -> exp GEQ exp .)
    )               reduce using rule 86 (exp -> exp GEQ exp .)
    ,               reduce using rule 86 (exp -> exp GEQ exp .)
    ]               reduce using rule 86 (exp -> exp GEQ exp .)
    END             reduce using rule 86 (exp -> exp GEQ exp .)
    ;               reduce using rule 86 (exp -> exp GEQ exp .)
    UNTIL           reduce using rule 86 (exp -> exp GEQ exp .)
    ELSE            reduce using rule 86 (exp -> exp GEQ exp .)
    DOWNTO          reduce using rule 86 (exp -> exp GEQ exp .)
    TO              reduce using rule 86 (exp -> exp GEQ exp .)
    +               shift and go to state 102
    -               shift and go to state 103
    *               shift and go to state 104
    /               shift and go to state 105
    %               shift and go to state 106

  ! +               [ reduce using rule 86 (exp -> exp GEQ exp .) ]
  ! -               [ reduce using rule 86 (exp -> exp GEQ exp .) ]
  ! *               [ reduce using rule 86 (exp -> exp GEQ exp .) ]
  ! /               [ reduce using rule 86 (exp -> exp GEQ exp .) ]
  ! %               [ reduce using rule 86 (exp -> exp GEQ exp .) ]
  ! EQ              [ shift and go to state 107 ]
  ! NEQ             [ shift and go to state 108 ]
  ! LT              [ shift and go to state 109 ]
  ! GT              [ shift and go to state 110 ]
  ! LEQ             [ shift and go to state 111 ]
  ! GEQ             [ shift and go to state 112 ]
  ! AND             [ shift and go to state 113 ]
  ! OR              [ shift and go to state 114 ]


state 152

    (87) exp -> exp AND exp .
    (76) exp -> exp . + exp
    (77) exp -> exp . - exp
    (78) exp -> exp . * exp
    (79) exp -> exp . / exp
    (80) exp -> exp . % exp
    (81) exp -> exp . EQ exp
    (82) exp -> exp . NEQ exp
    (83) exp -> exp . LT exp
    (84) exp -> exp . GT exp
    (85) exp -> exp . LEQ exp
    (86) exp -> exp . GEQ exp
    (87) exp -> exp . AND exp
    (88) exp -> exp . OR exp

    THEN            reduce using rule 87 (exp -> exp AND exp .)
    AND             reduce using rule 87 (exp -> exp AND exp .)
    OR              reduce using rule 87 (exp -> exp AND exp .)
    DO              reduce using rule 87 (exp -> exp AND exp .)
    OF              reduce using rule 87 (exp -> exp AND exp .)
    )               reduce using rule 87 (exp -> exp AND exp .)
    ,               reduce using rule 87 (exp -> exp AND exp .)
    ]               reduce using rule 87 (exp -> exp AND exp .)
    END             reduce using rule 87 (exp -> exp AND exp .)
    ;               reduce using rule 87 (exp -> exp AND exp .)
    UNTIL           reduce using rule 87 (exp -> exp AND exp .)
    ELSE            reduce using rule 87 (exp -> exp AND exp .)
    DOWNTO          reduce using rule 87 (exp -> exp AND exp .)
    TO              reduce using rule 87 (exp -> exp AND exp .)
    +               shift and go to state 102
    -               shift and go to state 103
    *               shift and go to state 104
    /               shift and go to state 105
    %               shift and go to state 106
    EQ              shift and go to state 107
    NEQ             shift and go to state 108
    LT              shift and go to state 109
    GT              shift and go to state 110
    LEQ             shift and go to state 111
    GEQ             shift and go to state 112

  ! +               [ reduce using rule 87 (exp -> exp AND exp .) ]
  ! -               [ reduce using rule 87 (exp -> exp AND exp .) ]
  ! *               [ reduce using rule 87 (exp -> exp AND exp .) ]
  ! /               [ reduce using rule 87 (exp -> exp AND exp .) ]
  ! %               [ reduce using rule 87 (exp -> exp AND exp .) ]
  ! EQ              [ reduce using rule 87 (exp -> exp AND exp .) ]
  ! NEQ             [ reduce using rule 87 (exp -> exp AND exp .) ]
  ! LT              [ reduce using rule 87 (exp -> exp AND exp .) ]
  ! GT              [ reduce using rule 87 (exp -> exp AND exp .) ]
  ! LEQ             [ reduce using rule 87 (exp -> exp AND exp .) ]
  ! GEQ             [ reduce using rule 87 (exp -> exp AND exp .) ]
  ! AND             [ shift and go to state 113 ]
  ! OR              [ shift and go to state 114 ]


state 153

    (88) exp -> exp OR exp .
    (76) exp -> exp . + exp
    (77) exp -> exp . - exp
    (78) exp -> exp . * exp
    (79) exp -> exp . / exp
    (80) exp -> exp . % exp
    (81) exp -> exp . EQ exp
    (82) exp -> exp . NEQ exp
    (83) exp -> exp . LT exp
    (84) exp -> exp . GT exp
    (85) exp -> exp . LEQ exp
    (86) exp -> exp . GEQ exp
    (87) exp -> exp . AND exp
    (88) exp -> exp . OR exp

    THEN            reduce using rule 88 (exp -> exp OR exp .)
    OR              reduce using rule 88 (exp -> exp OR exp .)
    DO              reduce using rule 88 (exp -> exp OR exp .)
    OF              reduce using rule 88 (exp -> exp OR exp .)
    )               reduce using rule 88 (exp -> exp OR exp .)
    ,               reduce using rule 88 (exp -> exp OR exp .)
    ]               reduce using rule 88 (exp -> exp OR exp .)
    END             reduce using rule 88 (exp -> exp OR exp .)
    ;               reduce using rule 88 (exp -> exp OR exp .)
    UNTIL           reduce using rule 88 (exp -> exp OR exp .)
    ELSE            reduce using rule 88 (exp -> exp OR exp .)
    DOWNTO          reduce using rule 88 (exp -> exp OR exp .)
    TO              reduce using rule 88 (exp -> exp OR exp .)
    +               shift and go to state 102
    -               shift and go to state 103
    *               shift and go to state 104
    /               shift and go to state 105
    %               shift and go to state 106
    EQ              shift and go to state 107
    NEQ             shift and go to state 108
    LT              shift and go to state 109
    GT              shift and go to state 110
    LEQ             shift and go to state 111
    GEQ             shift and go to state 112
    AND             shift and go to state 113

  ! +               [ reduce using rule 88 (exp -> exp OR exp .) ]
  ! -               [ reduce using rule 88 (exp -> exp OR exp .) ]
  ! *               [ reduce using rule 88 (exp -> exp OR exp .) ]
  ! /               [ reduce using rule 88 (exp -> exp OR exp .) ]
  ! %               [ reduce using rule 88 (exp -> exp OR exp .) ]
  ! EQ              [ reduce using rule 88 (exp -> exp OR exp .) ]
  ! NEQ             [ reduce using rule 88 (exp -> exp OR exp .) ]
  ! LT              [ reduce using rule 88 (exp -> exp OR exp .) ]
  ! GT              [ reduce using rule 88 (exp -> exp OR exp .) ]
  ! LEQ             [ reduce using rule 88 (exp -> exp OR exp .) ]
  ! GEQ             [ reduce using rule 88 (exp -> exp OR exp .) ]
  ! AND             [ reduce using rule 88 (exp -> exp OR exp .) ]
  ! OR              [ shift and go to state 114 ]


state 154

    (92) exp -> ( exp ) .

    THEN            reduce using rule 92 (exp -> ( exp ) .)
    +               reduce using rule 92 (exp -> ( exp ) .)
    -               reduce using rule 92 (exp -> ( exp ) .)
    *               reduce using rule 92 (exp -> ( exp ) .)
    /               reduce using rule 92 (exp -> ( exp ) .)
    %               reduce using rule 92 (exp -> ( exp ) .)
    EQ              reduce using rule 92 (exp -> ( exp ) .)
    NEQ             reduce using rule 92 (exp -> ( exp ) .)
    LT              reduce using rule 92 (exp -> ( exp ) .)
    GT              reduce using rule 92 (exp -> ( exp ) .)
    LEQ             reduce using rule 92 (exp -> ( exp ) .)
    GEQ             reduce using rule 92 (exp -> ( exp ) .)
    AND             reduce using rule 92 (exp -> ( exp ) .)
    OR              reduce using rule 92 (exp -> ( exp ) .)
    DO              reduce using rule 92 (exp -> ( exp ) .)
    OF              reduce using rule 92 (exp -> ( exp ) .)
    )               reduce using rule 92 (exp -> ( exp ) .)
    ,               reduce using rule 92 (exp -> ( exp ) .)
    ]               reduce using rule 92 (exp -> ( exp ) .)
    END             reduce using rule 92 (exp -> ( exp ) .)
    ;               reduce using rule 92 (exp -> ( exp ) .)
    UNTIL           reduce using rule 92 (exp -> ( exp ) .)
    ELSE            reduce using rule 92 (exp -> ( exp ) .)
    DOWNTO          reduce using rule 92 (exp -> ( exp ) .)
    TO              reduce using rule 92 (exp -> ( exp ) .)


state 155

    (95) exp -> ID [ exp . ]
    (76) exp -> exp . + exp
    (77) exp -> exp . - exp
    (78) exp -> exp . * exp
    (79) exp -> exp . / exp
    (80) exp -> exp . % exp
    (81) exp -> exp . EQ exp
    (82) exp -> exp . NEQ exp
    (83) exp -> exp . LT exp
    (84) exp -> exp . GT exp
    (85) exp -> exp . LEQ exp
    (86) exp -> exp . GEQ exp
    (87) exp -> exp . AND exp
    (88) exp -> exp . OR exp

    ]               shift and go to state 182
    +               shift and go to state 102
    -               shift and go to state 103
    *               shift and go to state 104
    /               shift and go to state 105
    %               shift and go to state 106
    EQ              shift and go to state 107
    NEQ             shift and go to state 108
    LT              shift and go to state 109
    GT              shift and go to state 110
    LEQ             shift and go to state 111
    GEQ             shift and go to state 112
    AND             shift and go to state 113
    OR              shift and go to state 114


state 156

    (51) while_stmt -> WHILE exp DO stmt .

    END             reduce using rule 51 (while_stmt -> WHILE exp DO stmt .)
    ;               reduce using rule 51 (while_stmt -> WHILE exp DO stmt .)
    UNTIL           reduce using rule 51 (while_stmt -> WHILE exp DO stmt .)
    ELSE            reduce using rule 51 (while_stmt -> WHILE exp DO stmt .)


state 157

    (52) repeat_stmt -> REPEAT stmt semicolon_stmt_list UNTIL . exp
    (75) exp -> . call_stmt
    (76) exp -> . exp + exp
    (77) exp -> . exp - exp
    (78) exp -> . exp * exp
    (79) exp -> . exp / exp
    (80) exp -> . exp % exp
    (81) exp -> . exp EQ exp
    (82) exp -> . exp NEQ exp
    (83) exp -> . exp LT exp
    (84) exp -> . exp GT exp
    (85) exp -> . exp LEQ exp
    (86) exp -> . exp GEQ exp
    (87) exp -> . exp AND exp
    (88) exp -> . exp OR exp
    (89) exp -> . NOT exp
    (90) exp -> . - exp
    (91) exp -> . + exp
    (92) exp -> . ( exp )
    (93) exp -> . ID
    (94) exp -> . literal
    (95) exp -> . ID [ exp ]
    (60) call_stmt -> . ID ( exp comma_exp_list )
    (61) call_stmt -> . vartype ( exp )
    (62) call_stmt -> . ID ( )
    (70) literal -> . LITERAL_INT
    (71) literal -> . LITERAL_REAL
    (72) literal -> . LITERAL_BOOL
    (73) literal -> . LITERAL_CHAR
    (74) literal -> . LITERAL_STRING
    (27) vartype -> . INT
    (28) vartype -> . REAL
    (29) vartype -> . BOOL
    (30) vartype -> . CHAR
    (31) vartype -> . STRING
    (32) vartype -> . ARRAY [ LITERAL_INT ] OF vartype
    (33) vartype -> . ARRAY [ LITERAL_INT RANGE LITERAL_INT ] OF vartype

    NOT             shift and go to state 67
    -               shift and go to state 66
    +               shift and go to state 65
    (               shift and go to state 68
    ID              shift and go to state 69
    LITERAL_INT     shift and go to state 71
    LITERAL_REAL    shift and go to state 72
    LITERAL_BOOL    shift and go to state 73
    LITERAL_CHAR    shift and go to state 74
    LITERAL_STRING  shift and go to state 75
    INT             shift and go to state 38
    REAL            shift and go to state 39
    BOOL            shift and go to state 40
    CHAR            shift and go to state 41
    STRING          shift and go to state 42
    ARRAY           shift and go to state 43

    exp                            shift and go to state 183
    call_stmt                      shift and go to state 64
    literal                        shift and go to state 70
    vartype                        shift and go to state 31

state 158

    (53) case_stmt -> CASE exp OF case_exp_list . END
    (54) case_exp_list -> case_exp_list . ; case_exp

    END             shift and go to state 184
    ;               shift and go to state 185


state 159

    (55) case_exp_list -> case_exp .

    END             reduce using rule 55 (case_exp_list -> case_exp .)
    ;               reduce using rule 55 (case_exp_list -> case_exp .)


state 160

    (56) case_exp -> literal . : stmt

    :               shift and go to state 186


state 161

    (57) case_exp -> ID . : stmt

    :               shift and go to state 187


state 162

    (32) vartype -> ARRAY [ LITERAL_INT ] . OF vartype

    OF              shift and go to state 188


state 163

    (33) vartype -> ARRAY [ LITERAL_INT RANGE . LITERAL_INT ] OF vartype

    LITERAL_INT     shift and go to state 189


state 164

    (11) var -> id_list : vartype ; .

    ID              reduce using rule 11 (var -> id_list : vartype ; .)
    BEGIN           reduce using rule 11 (var -> id_list : vartype ; .)
    VAR             reduce using rule 11 (var -> id_list : vartype ; .)
    LABEL           reduce using rule 11 (var -> id_list : vartype ; .)
    CONST           reduce using rule 11 (var -> id_list : vartype ; .)
    PROCEDURE       reduce using rule 11 (var -> id_list : vartype ; .)
    FUNCTION        reduce using rule 11 (var -> id_list : vartype ; .)


state 165

    (12) var -> id_list : vartype EQ . exp ;
    (75) exp -> . call_stmt
    (76) exp -> . exp + exp
    (77) exp -> . exp - exp
    (78) exp -> . exp * exp
    (79) exp -> . exp / exp
    (80) exp -> . exp % exp
    (81) exp -> . exp EQ exp
    (82) exp -> . exp NEQ exp
    (83) exp -> . exp LT exp
    (84) exp -> . exp GT exp
    (85) exp -> . exp LEQ exp
    (86) exp -> . exp GEQ exp
    (87) exp -> . exp AND exp
    (88) exp -> . exp OR exp
    (89) exp -> . NOT exp
    (90) exp -> . - exp
    (91) exp -> . + exp
    (92) exp -> . ( exp )
    (93) exp -> . ID
    (94) exp -> . literal
    (95) exp -> . ID [ exp ]
    (60) call_stmt -> . ID ( exp comma_exp_list )
    (61) call_stmt -> . vartype ( exp )
    (62) call_stmt -> . ID ( )
    (70) literal -> . LITERAL_INT
    (71) literal -> . LITERAL_REAL
    (72) literal -> . LITERAL_BOOL
    (73) literal -> . LITERAL_CHAR
    (74) literal -> . LITERAL_STRING
    (27) vartype -> . INT
    (28) vartype -> . REAL
    (29) vartype -> . BOOL
    (30) vartype -> . CHAR
    (31) vartype -> . STRING
    (32) vartype -> . ARRAY [ LITERAL_INT ] OF vartype
    (33) vartype -> . ARRAY [ LITERAL_INT RANGE LITERAL_INT ] OF vartype

    NOT             shift and go to state 67
    -               shift and go to state 66
    +               shift and go to state 65
    (               shift and go to state 68
    ID              shift and go to state 69
    LITERAL_INT     shift and go to state 71
    LITERAL_REAL    shift and go to state 72
    LITERAL_BOOL    shift and go to state 73
    LITERAL_CHAR    shift and go to state 74
    LITERAL_STRING  shift and go to state 75
    INT             shift and go to state 38
    REAL            shift and go to state 39
    BOOL            shift and go to state 40
    CHAR            shift and go to state 41
    STRING          shift and go to state 42
    ARRAY           shift and go to state 43

    vartype                        shift and go to state 31
    exp                            shift and go to state 190
    call_stmt                      shift and go to state 64
    literal                        shift and go to state 70

state 166

    (17) comma_id_list -> comma_id_list , ID .

    ,               reduce using rule 17 (comma_id_list -> comma_id_list , ID .)
    :               reduce using rule 17 (comma_id_list -> comma_id_list , ID .)
    ;               reduce using rule 17 (comma_id_list -> comma_id_list , ID .)
    EQ              reduce using rule 17 (comma_id_list -> comma_id_list , ID .)


state 167

    (15) const_exp -> id_list EQ literal ; .

    ID              reduce using rule 15 (const_exp -> id_list EQ literal ; .)
    BEGIN           reduce using rule 15 (const_exp -> id_list EQ literal ; .)
    VAR             reduce using rule 15 (const_exp -> id_list EQ literal ; .)
    LABEL           reduce using rule 15 (const_exp -> id_list EQ literal ; .)
    CONST           reduce using rule 15 (const_exp -> id_list EQ literal ; .)
    PROCEDURE       reduce using rule 15 (const_exp -> id_list EQ literal ; .)
    FUNCTION        reduce using rule 15 (const_exp -> id_list EQ literal ; .)


state 168

    (19) header -> PROCEDURE ID ( formal_list ) .

    ;               reduce using rule 19 (header -> PROCEDURE ID ( formal_list ) .)


state 169

    (23) formal_list -> formal semicolon_formal_list .
    (25) semicolon_formal_list -> semicolon_formal_list . ; formal

    )               reduce using rule 23 (formal_list -> formal semicolon_formal_list .)
    ;               shift and go to state 191


state 170

    (26) semicolon_formal_list -> empty .

    ;               reduce using rule 26 (semicolon_formal_list -> empty .)
    )               reduce using rule 26 (semicolon_formal_list -> empty .)


state 171

    (24) formal -> id_list : . vartype
    (27) vartype -> . INT
    (28) vartype -> . REAL
    (29) vartype -> . BOOL
    (30) vartype -> . CHAR
    (31) vartype -> . STRING
    (32) vartype -> . ARRAY [ LITERAL_INT ] OF vartype
    (33) vartype -> . ARRAY [ LITERAL_INT RANGE LITERAL_INT ] OF vartype

    INT             shift and go to state 38
    REAL            shift and go to state 39
    BOOL            shift and go to state 40
    CHAR            shift and go to state 41
    STRING          shift and go to state 42
    ARRAY           shift and go to state 43

    vartype                        shift and go to state 192

state 172

    (21) header -> FUNCTION ID ( formal_list ) . : vartype

    :               shift and go to state 193


state 173

    (22) header -> FUNCTION ID ( ) : . vartype
    (27) vartype -> . INT
    (28) vartype -> . REAL
    (29) vartype -> . BOOL
    (30) vartype -> . CHAR
    (31) vartype -> . STRING
    (32) vartype -> . ARRAY [ LITERAL_INT ] OF vartype
    (33) vartype -> . ARRAY [ LITERAL_INT RANGE LITERAL_INT ] OF vartype

    INT             shift and go to state 38
    REAL            shift and go to state 39
    BOOL            shift and go to state 40
    CHAR            shift and go to state 41
    STRING          shift and go to state 42
    ARRAY           shift and go to state 43

    vartype                        shift and go to state 194

state 174

    (60) call_stmt -> ID ( exp comma_exp_list ) .

    END             reduce using rule 60 (call_stmt -> ID ( exp comma_exp_list ) .)
    ;               reduce using rule 60 (call_stmt -> ID ( exp comma_exp_list ) .)
    THEN            reduce using rule 60 (call_stmt -> ID ( exp comma_exp_list ) .)
    +               reduce using rule 60 (call_stmt -> ID ( exp comma_exp_list ) .)
    -               reduce using rule 60 (call_stmt -> ID ( exp comma_exp_list ) .)
    *               reduce using rule 60 (call_stmt -> ID ( exp comma_exp_list ) .)
    /               reduce using rule 60 (call_stmt -> ID ( exp comma_exp_list ) .)
    %               reduce using rule 60 (call_stmt -> ID ( exp comma_exp_list ) .)
    EQ              reduce using rule 60 (call_stmt -> ID ( exp comma_exp_list ) .)
    NEQ             reduce using rule 60 (call_stmt -> ID ( exp comma_exp_list ) .)
    LT              reduce using rule 60 (call_stmt -> ID ( exp comma_exp_list ) .)
    GT              reduce using rule 60 (call_stmt -> ID ( exp comma_exp_list ) .)
    LEQ             reduce using rule 60 (call_stmt -> ID ( exp comma_exp_list ) .)
    GEQ             reduce using rule 60 (call_stmt -> ID ( exp comma_exp_list ) .)
    AND             reduce using rule 60 (call_stmt -> ID ( exp comma_exp_list ) .)
    OR              reduce using rule 60 (call_stmt -> ID ( exp comma_exp_list ) .)
    DO              reduce using rule 60 (call_stmt -> ID ( exp comma_exp_list ) .)
    UNTIL           reduce using rule 60 (call_stmt -> ID ( exp comma_exp_list ) .)
    OF              reduce using rule 60 (call_stmt -> ID ( exp comma_exp_list ) .)
    ELSE            reduce using rule 60 (call_stmt -> ID ( exp comma_exp_list ) .)
    )               reduce using rule 60 (call_stmt -> ID ( exp comma_exp_list ) .)
    ,               reduce using rule 60 (call_stmt -> ID ( exp comma_exp_list ) .)
    ]               reduce using rule 60 (call_stmt -> ID ( exp comma_exp_list ) .)
    DOWNTO          reduce using rule 60 (call_stmt -> ID ( exp comma_exp_list ) .)
    TO              reduce using rule 60 (call_stmt -> ID ( exp comma_exp_list ) .)


state 175

    (63) comma_exp_list -> comma_exp_list , . exp
    (75) exp -> . call_stmt
    (76) exp -> . exp + exp
    (77) exp -> . exp - exp
    (78) exp -> . exp * exp
    (79) exp -> . exp / exp
    (80) exp -> . exp % exp
    (81) exp -> . exp EQ exp
    (82) exp -> . exp NEQ exp
    (83) exp -> . exp LT exp
    (84) exp -> . exp GT exp
    (85) exp -> . exp LEQ exp
    (86) exp -> . exp GEQ exp
    (87) exp -> . exp AND exp
    (88) exp -> . exp OR exp
    (89) exp -> . NOT exp
    (90) exp -> . - exp
    (91) exp -> . + exp
    (92) exp -> . ( exp )
    (93) exp -> . ID
    (94) exp -> . literal
    (95) exp -> . ID [ exp ]
    (60) call_stmt -> . ID ( exp comma_exp_list )
    (61) call_stmt -> . vartype ( exp )
    (62) call_stmt -> . ID ( )
    (70) literal -> . LITERAL_INT
    (71) literal -> . LITERAL_REAL
    (72) literal -> . LITERAL_BOOL
    (73) literal -> . LITERAL_CHAR
    (74) literal -> . LITERAL_STRING
    (27) vartype -> . INT
    (28) vartype -> . REAL
    (29) vartype -> . BOOL
    (30) vartype -> . CHAR
    (31) vartype -> . STRING
    (32) vartype -> . ARRAY [ LITERAL_INT ] OF vartype
    (33) vartype -> . ARRAY [ LITERAL_INT RANGE LITERAL_INT ] OF vartype

    NOT             shift and go to state 67
    -               shift and go to state 66
    +               shift and go to state 65
    (               shift and go to state 68
    ID              shift and go to state 69
    LITERAL_INT     shift and go to state 71
    LITERAL_REAL    shift and go to state 72
    LITERAL_BOOL    shift and go to state 73
    LITERAL_CHAR    shift and go to state 74
    LITERAL_STRING  shift and go to state 75
    INT             shift and go to state 38
    REAL            shift and go to state 39
    BOOL            shift and go to state 40
    CHAR            shift and go to state 41
    STRING          shift and go to state 42
    ARRAY           shift and go to state 43

    exp                            shift and go to state 195
    call_stmt                      shift and go to state 64
    literal                        shift and go to state 70
    vartype                        shift and go to state 31

state 176

    (48) for_stmt -> FOR ID ASSIGN exp direction . exp DO stmt
    (75) exp -> . call_stmt
    (76) exp -> . exp + exp
    (77) exp -> . exp - exp
    (78) exp -> . exp * exp
    (79) exp -> . exp / exp
    (80) exp -> . exp % exp
    (81) exp -> . exp EQ exp
    (82) exp -> . exp NEQ exp
    (83) exp -> . exp LT exp
    (84) exp -> . exp GT exp
    (85) exp -> . exp LEQ exp
    (86) exp -> . exp GEQ exp
    (87) exp -> . exp AND exp
    (88) exp -> . exp OR exp
    (89) exp -> . NOT exp
    (90) exp -> . - exp
    (91) exp -> . + exp
    (92) exp -> . ( exp )
    (93) exp -> . ID
    (94) exp -> . literal
    (95) exp -> . ID [ exp ]
    (60) call_stmt -> . ID ( exp comma_exp_list )
    (61) call_stmt -> . vartype ( exp )
    (62) call_stmt -> . ID ( )
    (70) literal -> . LITERAL_INT
    (71) literal -> . LITERAL_REAL
    (72) literal -> . LITERAL_BOOL
    (73) literal -> . LITERAL_CHAR
    (74) literal -> . LITERAL_STRING
    (27) vartype -> . INT
    (28) vartype -> . REAL
    (29) vartype -> . BOOL
    (30) vartype -> . CHAR
    (31) vartype -> . STRING
    (32) vartype -> . ARRAY [ LITERAL_INT ] OF vartype
    (33) vartype -> . ARRAY [ LITERAL_INT RANGE LITERAL_INT ] OF vartype

    NOT             shift and go to state 67
    -               shift and go to state 66
    +               shift and go to state 65
    (               shift and go to state 68
    ID              shift and go to state 69
    LITERAL_INT     shift and go to state 71
    LITERAL_REAL    shift and go to state 72
    LITERAL_BOOL    shift and go to state 73
    LITERAL_CHAR    shift and go to state 74
    LITERAL_STRING  shift and go to state 75
    INT             shift and go to state 38
    REAL            shift and go to state 39
    BOOL            shift and go to state 40
    CHAR            shift and go to state 41
    STRING          shift and go to state 42
    ARRAY           shift and go to state 43

    exp                            shift and go to state 196
    call_stmt                      shift and go to state 64
    literal                        shift and go to state 70
    vartype                        shift and go to state 31

state 177

    (49) direction -> DOWNTO .

    NOT             reduce using rule 49 (direction -> DOWNTO .)
    -               reduce using rule 49 (direction -> DOWNTO .)
    +               reduce using rule 49 (direction -> DOWNTO .)
    (               reduce using rule 49 (direction -> DOWNTO .)
    ID              reduce using rule 49 (direction -> DOWNTO .)
    LITERAL_INT     reduce using rule 49 (direction -> DOWNTO .)
    LITERAL_REAL    reduce using rule 49 (direction -> DOWNTO .)
    LITERAL_BOOL    reduce using rule 49 (direction -> DOWNTO .)
    LITERAL_CHAR    reduce using rule 49 (direction -> DOWNTO .)
    LITERAL_STRING  reduce using rule 49 (direction -> DOWNTO .)
    INT             reduce using rule 49 (direction -> DOWNTO .)
    REAL            reduce using rule 49 (direction -> DOWNTO .)
    BOOL            reduce using rule 49 (direction -> DOWNTO .)
    CHAR            reduce using rule 49 (direction -> DOWNTO .)
    STRING          reduce using rule 49 (direction -> DOWNTO .)
    ARRAY           reduce using rule 49 (direction -> DOWNTO .)


state 178

    (50) direction -> TO .

    NOT             reduce using rule 50 (direction -> TO .)
    -               reduce using rule 50 (direction -> TO .)
    +               reduce using rule 50 (direction -> TO .)
    (               reduce using rule 50 (direction -> TO .)
    ID              reduce using rule 50 (direction -> TO .)
    LITERAL_INT     reduce using rule 50 (direction -> TO .)
    LITERAL_REAL    reduce using rule 50 (direction -> TO .)
    LITERAL_BOOL    reduce using rule 50 (direction -> TO .)
    LITERAL_CHAR    reduce using rule 50 (direction -> TO .)
    LITERAL_STRING  reduce using rule 50 (direction -> TO .)
    INT             reduce using rule 50 (direction -> TO .)
    REAL            reduce using rule 50 (direction -> TO .)
    BOOL            reduce using rule 50 (direction -> TO .)
    CHAR            reduce using rule 50 (direction -> TO .)
    STRING          reduce using rule 50 (direction -> TO .)
    ARRAY           reduce using rule 50 (direction -> TO .)


state 179

    (65) if_stmt -> IF exp THEN stmt else_stmt .

    END             reduce using rule 65 (if_stmt -> IF exp THEN stmt else_stmt .)
    ;               reduce using rule 65 (if_stmt -> IF exp THEN stmt else_stmt .)
    UNTIL           reduce using rule 65 (if_stmt -> IF exp THEN stmt else_stmt .)
    ELSE            reduce using rule 65 (if_stmt -> IF exp THEN stmt else_stmt .)


state 180

    (66) else_stmt -> ELSE . stmt
    (36) stmt -> . ID : non_label_stmt
    (37) stmt -> . non_label_stmt
    (38) non_label_stmt -> . assign_stmt
    (39) non_label_stmt -> . call_stmt
    (40) non_label_stmt -> . for_stmt
    (41) non_label_stmt -> . if_stmt
    (42) non_label_stmt -> . while_stmt
    (43) non_label_stmt -> . repeat_stmt
    (44) non_label_stmt -> . case_stmt
    (45) non_label_stmt -> . goto_stmt
    (46) non_label_stmt -> . compound_stmt
    (47) assign_stmt -> . lvalue ASSIGN exp
    (60) call_stmt -> . ID ( exp comma_exp_list )
    (61) call_stmt -> . vartype ( exp )
    (62) call_stmt -> . ID ( )
    (48) for_stmt -> . FOR ID ASSIGN exp direction exp DO stmt
    (65) if_stmt -> . IF exp THEN stmt else_stmt
    (51) while_stmt -> . WHILE exp DO stmt
    (52) repeat_stmt -> . REPEAT stmt semicolon_stmt_list UNTIL exp
    (53) case_stmt -> . CASE exp OF case_exp_list END
    (58) goto_stmt -> . GOTO ID
    (59) compound_stmt -> . BEGIN stmt semicolon_stmt_list END
    (68) lvalue -> . ID
    (69) lvalue -> . ID [ exp ]
    (27) vartype -> . INT
    (28) vartype -> . REAL
    (29) vartype -> . BOOL
    (30) vartype -> . CHAR
    (31) vartype -> . STRING
    (32) vartype -> . ARRAY [ LITERAL_INT ] OF vartype
    (33) vartype -> . ARRAY [ LITERAL_INT RANGE LITERAL_INT ] OF vartype

    ID              shift and go to state 19
    FOR             shift and go to state 32
    IF              shift and go to state 33
    WHILE           shift and go to state 34
    REPEAT          shift and go to state 35
    CASE            shift and go to state 36
    GOTO            shift and go to state 37
    BEGIN           shift and go to state 11
    INT             shift and go to state 38
    REAL            shift and go to state 39
    BOOL            shift and go to state 40
    CHAR            shift and go to state 41
    STRING          shift and go to state 42
    ARRAY           shift and go to state 43

    stmt                           shift and go to state 197
    non_label_stmt                 shift and go to state 20
    assign_stmt                    shift and go to state 21
    call_stmt                      shift and go to state 22
    for_stmt                       shift and go to state 23
    if_stmt                        shift and go to state 24
    while_stmt                     shift and go to state 25
    repeat_stmt                    shift and go to state 26
    case_stmt                      shift and go to state 27
    goto_stmt                      shift and go to state 28
    compound_stmt                  shift and go to state 29
    lvalue                         shift and go to state 30
    vartype                        shift and go to state 31

state 181

    (67) else_stmt -> empty .

    END             reduce using rule 67 (else_stmt -> empty .)
    ;               reduce using rule 67 (else_stmt -> empty .)
    UNTIL           reduce using rule 67 (else_stmt -> empty .)
    ELSE            reduce using rule 67 (else_stmt -> empty .)


state 182

    (95) exp -> ID [ exp ] .

    THEN            reduce using rule 95 (exp -> ID [ exp ] .)
    +               reduce using rule 95 (exp -> ID [ exp ] .)
    -               reduce using rule 95 (exp -> ID [ exp ] .)
    *               reduce using rule 95 (exp -> ID [ exp ] .)
    /               reduce using rule 95 (exp -> ID [ exp ] .)
    %               reduce using rule 95 (exp -> ID [ exp ] .)
    EQ              reduce using rule 95 (exp -> ID [ exp ] .)
    NEQ             reduce using rule 95 (exp -> ID [ exp ] .)
    LT              reduce using rule 95 (exp -> ID [ exp ] .)
    GT              reduce using rule 95 (exp -> ID [ exp ] .)
    LEQ             reduce using rule 95 (exp -> ID [ exp ] .)
    GEQ             reduce using rule 95 (exp -> ID [ exp ] .)
    AND             reduce using rule 95 (exp -> ID [ exp ] .)
    OR              reduce using rule 95 (exp -> ID [ exp ] .)
    DO              reduce using rule 95 (exp -> ID [ exp ] .)
    OF              reduce using rule 95 (exp -> ID [ exp ] .)
    )               reduce using rule 95 (exp -> ID [ exp ] .)
    ,               reduce using rule 95 (exp -> ID [ exp ] .)
    ]               reduce using rule 95 (exp -> ID [ exp ] .)
    END             reduce using rule 95 (exp -> ID [ exp ] .)
    ;               reduce using rule 95 (exp -> ID [ exp ] .)
    UNTIL           reduce using rule 95 (exp -> ID [ exp ] .)
    ELSE            reduce using rule 95 (exp -> ID [ exp ] .)
    DOWNTO          reduce using rule 95 (exp -> ID [ exp ] .)
    TO              reduce using rule 95 (exp -> ID [ exp ] .)


state 183

    (52) repeat_stmt -> REPEAT stmt semicolon_stmt_list UNTIL exp .
    (76) exp -> exp . + exp
    (77) exp -> exp . - exp
    (78) exp -> exp . * exp
    (79) exp -> exp . / exp
    (80) exp -> exp . % exp
    (81) exp -> exp . EQ exp
    (82) exp -> exp . NEQ exp
    (83) exp -> exp . LT exp
    (84) exp -> exp . GT exp
    (85) exp -> exp . LEQ exp
    (86) exp -> exp . GEQ exp
    (87) exp -> exp . AND exp
    (88) exp -> exp . OR exp

    END             reduce using rule 52 (repeat_stmt -> REPEAT stmt semicolon_stmt_list UNTIL exp .)
    ;               reduce using rule 52 (repeat_stmt -> REPEAT stmt semicolon_stmt_list UNTIL exp .)
    UNTIL           reduce using rule 52 (repeat_stmt -> REPEAT stmt semicolon_stmt_list UNTIL exp .)
    ELSE            reduce using rule 52 (repeat_stmt -> REPEAT stmt semicolon_stmt_list UNTIL exp .)
    +               shift and go to state 102
    -               shift and go to state 103
    *               shift and go to state 104
    /               shift and go to state 105
    %               shift and go to state 106
    EQ              shift and go to state 107
    NEQ             shift and go to state 108
    LT              shift and go to state 109
    GT              shift and go to state 110
    LEQ             shift and go to state 111
    GEQ             shift and go to state 112
    AND             shift and go to state 113
    OR              shift and go to state 114


state 184

    (53) case_stmt -> CASE exp OF case_exp_list END .

    END             reduce using rule 53 (case_stmt -> CASE exp OF case_exp_list END .)
    ;               reduce using rule 53 (case_stmt -> CASE exp OF case_exp_list END .)
    UNTIL           reduce using rule 53 (case_stmt -> CASE exp OF case_exp_list END .)
    ELSE            reduce using rule 53 (case_stmt -> CASE exp OF case_exp_list END .)


state 185

    (54) case_exp_list -> case_exp_list ; . case_exp
    (56) case_exp -> . literal : stmt
    (57) case_exp -> . ID : stmt
    (70) literal -> . LITERAL_INT
    (71) literal -> . LITERAL_REAL
    (72) literal -> . LITERAL_BOOL
    (73) literal -> . LITERAL_CHAR
    (74) literal -> . LITERAL_STRING

    ID              shift and go to state 161
    LITERAL_INT     shift and go to state 71
    LITERAL_REAL    shift and go to state 72
    LITERAL_BOOL    shift and go to state 73
    LITERAL_CHAR    shift and go to state 74
    LITERAL_STRING  shift and go to state 75

    case_exp                       shift and go to state 198
    literal                        shift and go to state 160

state 186

    (56) case_exp -> literal : . stmt
    (36) stmt -> . ID : non_label_stmt
    (37) stmt -> . non_label_stmt
    (38) non_label_stmt -> . assign_stmt
    (39) non_label_stmt -> . call_stmt
    (40) non_label_stmt -> . for_stmt
    (41) non_label_stmt -> . if_stmt
    (42) non_label_stmt -> . while_stmt
    (43) non_label_stmt -> . repeat_stmt
    (44) non_label_stmt -> . case_stmt
    (45) non_label_stmt -> . goto_stmt
    (46) non_label_stmt -> . compound_stmt
    (47) assign_stmt -> . lvalue ASSIGN exp
    (60) call_stmt -> . ID ( exp comma_exp_list )
    (61) call_stmt -> . vartype ( exp )
    (62) call_stmt -> . ID ( )
    (48) for_stmt -> . FOR ID ASSIGN exp direction exp DO stmt
    (65) if_stmt -> . IF exp THEN stmt else_stmt
    (51) while_stmt -> . WHILE exp DO stmt
    (52) repeat_stmt -> . REPEAT stmt semicolon_stmt_list UNTIL exp
    (53) case_stmt -> . CASE exp OF case_exp_list END
    (58) goto_stmt -> . GOTO ID
    (59) compound_stmt -> . BEGIN stmt semicolon_stmt_list END
    (68) lvalue -> . ID
    (69) lvalue -> . ID [ exp ]
    (27) vartype -> . INT
    (28) vartype -> . REAL
    (29) vartype -> . BOOL
    (30) vartype -> . CHAR
    (31) vartype -> . STRING
    (32) vartype -> . ARRAY [ LITERAL_INT ] OF vartype
    (33) vartype -> . ARRAY [ LITERAL_INT RANGE LITERAL_INT ] OF vartype

    ID              shift and go to state 19
    FOR             shift and go to state 32
    IF              shift and go to state 33
    WHILE           shift and go to state 34
    REPEAT          shift and go to state 35
    CASE            shift and go to state 36
    GOTO            shift and go to state 37
    BEGIN           shift and go to state 11
    INT             shift and go to state 38
    REAL            shift and go to state 39
    BOOL            shift and go to state 40
    CHAR            shift and go to state 41
    STRING          shift and go to state 42
    ARRAY           shift and go to state 43

    stmt                           shift and go to state 199
    non_label_stmt                 shift and go to state 20
    assign_stmt                    shift and go to state 21
    call_stmt                      shift and go to state 22
    for_stmt                       shift and go to state 23
    if_stmt                        shift and go to state 24
    while_stmt                     shift and go to state 25
    repeat_stmt                    shift and go to state 26
    case_stmt                      shift and go to state 27
    goto_stmt                      shift and go to state 28
    compound_stmt                  shift and go to state 29
    lvalue                         shift and go to state 30
    vartype                        shift and go to state 31

state 187

    (57) case_exp -> ID : . stmt
    (36) stmt -> . ID : non_label_stmt
    (37) stmt -> . non_label_stmt
    (38) non_label_stmt -> . assign_stmt
    (39) non_label_stmt -> . call_stmt
    (40) non_label_stmt -> . for_stmt
    (41) non_label_stmt -> . if_stmt
    (42) non_label_stmt -> . while_stmt
    (43) non_label_stmt -> . repeat_stmt
    (44) non_label_stmt -> . case_stmt
    (45) non_label_stmt -> . goto_stmt
    (46) non_label_stmt -> . compound_stmt
    (47) assign_stmt -> . lvalue ASSIGN exp
    (60) call_stmt -> . ID ( exp comma_exp_list )
    (61) call_stmt -> . vartype ( exp )
    (62) call_stmt -> . ID ( )
    (48) for_stmt -> . FOR ID ASSIGN exp direction exp DO stmt
    (65) if_stmt -> . IF exp THEN stmt else_stmt
    (51) while_stmt -> . WHILE exp DO stmt
    (52) repeat_stmt -> . REPEAT stmt semicolon_stmt_list UNTIL exp
    (53) case_stmt -> . CASE exp OF case_exp_list END
    (58) goto_stmt -> . GOTO ID
    (59) compound_stmt -> . BEGIN stmt semicolon_stmt_list END
    (68) lvalue -> . ID
    (69) lvalue -> . ID [ exp ]
    (27) vartype -> . INT
    (28) vartype -> . REAL
    (29) vartype -> . BOOL
    (30) vartype -> . CHAR
    (31) vartype -> . STRING
    (32) vartype -> . ARRAY [ LITERAL_INT ] OF vartype
    (33) vartype -> . ARRAY [ LITERAL_INT RANGE LITERAL_INT ] OF vartype

    ID              shift and go to state 19
    FOR             shift and go to state 32
    IF              shift and go to state 33
    WHILE           shift and go to state 34
    REPEAT          shift and go to state 35
    CASE            shift and go to state 36
    GOTO            shift and go to state 37
    BEGIN           shift and go to state 11
    INT             shift and go to state 38
    REAL            shift and go to state 39
    BOOL            shift and go to state 40
    CHAR            shift and go to state 41
    STRING          shift and go to state 42
    ARRAY           shift and go to state 43

    stmt                           shift and go to state 200
    non_label_stmt                 shift and go to state 20
    assign_stmt                    shift and go to state 21
    call_stmt                      shift and go to state 22
    for_stmt                       shift and go to state 23
    if_stmt                        shift and go to state 24
    while_stmt                     shift and go to state 25
    repeat_stmt                    shift and go to state 26
    case_stmt                      shift and go to state 27
    goto_stmt                      shift and go to state 28
    compound_stmt                  shift and go to state 29
    lvalue                         shift and go to state 30
    vartype                        shift and go to state 31

state 188

    (32) vartype -> ARRAY [ LITERAL_INT ] OF . vartype
    (27) vartype -> . INT
    (28) vartype -> . REAL
    (29) vartype -> . BOOL
    (30) vartype -> . CHAR
    (31) vartype -> . STRING
    (32) vartype -> . ARRAY [ LITERAL_INT ] OF vartype
    (33) vartype -> . ARRAY [ LITERAL_INT RANGE LITERAL_INT ] OF vartype

    INT             shift and go to state 38
    REAL            shift and go to state 39
    BOOL            shift and go to state 40
    CHAR            shift and go to state 41
    STRING          shift and go to state 42
    ARRAY           shift and go to state 43

    vartype                        shift and go to state 201

state 189

    (33) vartype -> ARRAY [ LITERAL_INT RANGE LITERAL_INT . ] OF vartype

    ]               shift and go to state 202


state 190

    (12) var -> id_list : vartype EQ exp . ;
    (76) exp -> exp . + exp
    (77) exp -> exp . - exp
    (78) exp -> exp . * exp
    (79) exp -> exp . / exp
    (80) exp -> exp . % exp
    (81) exp -> exp . EQ exp
    (82) exp -> exp . NEQ exp
    (83) exp -> exp . LT exp
    (84) exp -> exp . GT exp
    (85) exp -> exp . LEQ exp
    (86) exp -> exp . GEQ exp
    (87) exp -> exp . AND exp
    (88) exp -> exp . OR exp

    ;               shift and go to state 203
    +               shift and go to state 102
    -               shift and go to state 103
    *               shift and go to state 104
    /               shift and go to state 105
    %               shift and go to state 106
    EQ              shift and go to state 107
    NEQ             shift and go to state 108
    LT              shift and go to state 109
    GT              shift and go to state 110
    LEQ             shift and go to state 111
    GEQ             shift and go to state 112
    AND             shift and go to state 113
    OR              shift and go to state 114


state 191

    (25) semicolon_formal_list -> semicolon_formal_list ; . formal
    (24) formal -> . id_list : vartype
    (16) id_list -> . ID comma_id_list

    ID              shift and go to state 47

    formal                         shift and go to state 204
    id_list                        shift and go to state 131

state 192

    (24) formal -> id_list : vartype .

    ;               reduce using rule 24 (formal -> id_list : vartype .)
    )               reduce using rule 24 (formal -> id_list : vartype .)


state 193

    (21) header -> FUNCTION ID ( formal_list ) : . vartype
    (27) vartype -> . INT
    (28) vartype -> . REAL
    (29) vartype -> . BOOL
    (30) vartype -> . CHAR
    (31) vartype -> . STRING
    (32) vartype -> . ARRAY [ LITERAL_INT ] OF vartype
    (33) vartype -> . ARRAY [ LITERAL_INT RANGE LITERAL_INT ] OF vartype

    INT             shift and go to state 38
    REAL            shift and go to state 39
    BOOL            shift and go to state 40
    CHAR            shift and go to state 41
    STRING          shift and go to state 42
    ARRAY           shift and go to state 43

    vartype                        shift and go to state 205

state 194

    (22) header -> FUNCTION ID ( ) : vartype .

    ;               reduce using rule 22 (header -> FUNCTION ID ( ) : vartype .)


state 195

    (63) comma_exp_list -> comma_exp_list , exp .
    (76) exp -> exp . + exp
    (77) exp -> exp . - exp
    (78) exp -> exp . * exp
    (79) exp -> exp . / exp
    (80) exp -> exp . % exp
    (81) exp -> exp . EQ exp
    (82) exp -> exp . NEQ exp
    (83) exp -> exp . LT exp
    (84) exp -> exp . GT exp
    (85) exp -> exp . LEQ exp
    (86) exp -> exp . GEQ exp
    (87) exp -> exp . AND exp
    (88) exp -> exp . OR exp

    )               reduce using rule 63 (comma_exp_list -> comma_exp_list , exp .)
    ,               reduce using rule 63 (comma_exp_list -> comma_exp_list , exp .)
    +               shift and go to state 102
    -               shift and go to state 103
    *               shift and go to state 104
    /               shift and go to state 105
    %               shift and go to state 106
    EQ              shift and go to state 107
    NEQ             shift and go to state 108
    LT              shift and go to state 109
    GT              shift and go to state 110
    LEQ             shift and go to state 111
    GEQ             shift and go to state 112
    AND             shift and go to state 113
    OR              shift and go to state 114


state 196

    (48) for_stmt -> FOR ID ASSIGN exp direction exp . DO stmt
    (76) exp -> exp . + exp
    (77) exp -> exp . - exp
    (78) exp -> exp . * exp
    (79) exp -> exp . / exp
    (80) exp -> exp . % exp
    (81) exp -> exp . EQ exp
    (82) exp -> exp . NEQ exp
    (83) exp -> exp . LT exp
    (84) exp -> exp . GT exp
    (85) exp -> exp . LEQ exp
    (86) exp -> exp . GEQ exp
    (87) exp -> exp . AND exp
    (88) exp -> exp . OR exp

    DO              shift and go to state 206
    +               shift and go to state 102
    -               shift and go to state 103
    *               shift and go to state 104
    /               shift and go to state 105
    %               shift and go to state 106
    EQ              shift and go to state 107
    NEQ             shift and go to state 108
    LT              shift and go to state 109
    GT              shift and go to state 110
    LEQ             shift and go to state 111
    GEQ             shift and go to state 112
    AND             shift and go to state 113
    OR              shift and go to state 114


state 197

    (66) else_stmt -> ELSE stmt .

    END             reduce using rule 66 (else_stmt -> ELSE stmt .)
    ;               reduce using rule 66 (else_stmt -> ELSE stmt .)
    UNTIL           reduce using rule 66 (else_stmt -> ELSE stmt .)
    ELSE            reduce using rule 66 (else_stmt -> ELSE stmt .)


state 198

    (54) case_exp_list -> case_exp_list ; case_exp .

    END             reduce using rule 54 (case_exp_list -> case_exp_list ; case_exp .)
    ;               reduce using rule 54 (case_exp_list -> case_exp_list ; case_exp .)


state 199

    (56) case_exp -> literal : stmt .

    END             reduce using rule 56 (case_exp -> literal : stmt .)
    ;               reduce using rule 56 (case_exp -> literal : stmt .)


state 200

    (57) case_exp -> ID : stmt .

    END             reduce using rule 57 (case_exp -> ID : stmt .)
    ;               reduce using rule 57 (case_exp -> ID : stmt .)


state 201

    (32) vartype -> ARRAY [ LITERAL_INT ] OF vartype .

    (               reduce using rule 32 (vartype -> ARRAY [ LITERAL_INT ] OF vartype .)
    ;               reduce using rule 32 (vartype -> ARRAY [ LITERAL_INT ] OF vartype .)
    EQ              reduce using rule 32 (vartype -> ARRAY [ LITERAL_INT ] OF vartype .)
    )               reduce using rule 32 (vartype -> ARRAY [ LITERAL_INT ] OF vartype .)


state 202

    (33) vartype -> ARRAY [ LITERAL_INT RANGE LITERAL_INT ] . OF vartype

    OF              shift and go to state 207


state 203

    (12) var -> id_list : vartype EQ exp ; .

    ID              reduce using rule 12 (var -> id_list : vartype EQ exp ; .)
    BEGIN           reduce using rule 12 (var -> id_list : vartype EQ exp ; .)
    VAR             reduce using rule 12 (var -> id_list : vartype EQ exp ; .)
    LABEL           reduce using rule 12 (var -> id_list : vartype EQ exp ; .)
    CONST           reduce using rule 12 (var -> id_list : vartype EQ exp ; .)
    PROCEDURE       reduce using rule 12 (var -> id_list : vartype EQ exp ; .)
    FUNCTION        reduce using rule 12 (var -> id_list : vartype EQ exp ; .)


state 204

    (25) semicolon_formal_list -> semicolon_formal_list ; formal .

    ;               reduce using rule 25 (semicolon_formal_list -> semicolon_formal_list ; formal .)
    )               reduce using rule 25 (semicolon_formal_list -> semicolon_formal_list ; formal .)


state 205

    (21) header -> FUNCTION ID ( formal_list ) : vartype .

    ;               reduce using rule 21 (header -> FUNCTION ID ( formal_list ) : vartype .)


state 206

    (48) for_stmt -> FOR ID ASSIGN exp direction exp DO . stmt
    (36) stmt -> . ID : non_label_stmt
    (37) stmt -> . non_label_stmt
    (38) non_label_stmt -> . assign_stmt
    (39) non_label_stmt -> . call_stmt
    (40) non_label_stmt -> . for_stmt
    (41) non_label_stmt -> . if_stmt
    (42) non_label_stmt -> . while_stmt
    (43) non_label_stmt -> . repeat_stmt
    (44) non_label_stmt -> . case_stmt
    (45) non_label_stmt -> . goto_stmt
    (46) non_label_stmt -> . compound_stmt
    (47) assign_stmt -> . lvalue ASSIGN exp
    (60) call_stmt -> . ID ( exp comma_exp_list )
    (61) call_stmt -> . vartype ( exp )
    (62) call_stmt -> . ID ( )
    (48) for_stmt -> . FOR ID ASSIGN exp direction exp DO stmt
    (65) if_stmt -> . IF exp THEN stmt else_stmt
    (51) while_stmt -> . WHILE exp DO stmt
    (52) repeat_stmt -> . REPEAT stmt semicolon_stmt_list UNTIL exp
    (53) case_stmt -> . CASE exp OF case_exp_list END
    (58) goto_stmt -> . GOTO ID
    (59) compound_stmt -> . BEGIN stmt semicolon_stmt_list END
    (68) lvalue -> . ID
    (69) lvalue -> . ID [ exp ]
    (27) vartype -> . INT
    (28) vartype -> . REAL
    (29) vartype -> . BOOL
    (30) vartype -> . CHAR
    (31) vartype -> . STRING
    (32) vartype -> . ARRAY [ LITERAL_INT ] OF vartype
    (33) vartype -> . ARRAY [ LITERAL_INT RANGE LITERAL_INT ] OF vartype

    ID              shift and go to state 19
    FOR             shift and go to state 32
    IF              shift and go to state 33
    WHILE           shift and go to state 34
    REPEAT          shift and go to state 35
    CASE            shift and go to state 36
    GOTO            shift and go to state 37
    BEGIN           shift and go to state 11
    INT             shift and go to state 38
    REAL            shift and go to state 39
    BOOL            shift and go to state 40
    CHAR            shift and go to state 41
    STRING          shift and go to state 42
    ARRAY           shift and go to state 43

    stmt                           shift and go to state 208
    non_label_stmt                 shift and go to state 20
    assign_stmt                    shift and go to state 21
    call_stmt                      shift and go to state 22
    for_stmt                       shift and go to state 23
    if_stmt                        shift and go to state 24
    while_stmt                     shift and go to state 25
    repeat_stmt                    shift and go to state 26
    case_stmt                      shift and go to state 27
    goto_stmt                      shift and go to state 28
    compound_stmt                  shift and go to state 29
    lvalue                         shift and go to state 30
    vartype                        shift and go to state 31

state 207

    (33) vartype -> ARRAY [ LITERAL_INT RANGE LITERAL_INT ] OF . vartype
    (27) vartype -> . INT
    (28) vartype -> . REAL
    (29) vartype -> . BOOL
    (30) vartype -> . CHAR
    (31) vartype -> . STRING
    (32) vartype -> . ARRAY [ LITERAL_INT ] OF vartype
    (33) vartype -> . ARRAY [ LITERAL_INT RANGE LITERAL_INT ] OF vartype

    INT             shift and go to state 38
    REAL            shift and go to state 39
    BOOL            shift and go to state 40
    CHAR            shift and go to state 41
    STRING          shift and go to state 42
    ARRAY           shift and go to state 43

    vartype                        shift and go to state 209

state 208

    (48) for_stmt -> FOR ID ASSIGN exp direction exp DO stmt .

    END             reduce using rule 48 (for_stmt -> FOR ID ASSIGN exp direction exp DO stmt .)
    ;               reduce using rule 48 (for_stmt -> FOR ID ASSIGN exp direction exp DO stmt .)
    UNTIL           reduce using rule 48 (for_stmt -> FOR ID ASSIGN exp direction exp DO stmt .)
    ELSE            reduce using rule 48 (for_stmt -> FOR ID ASSIGN exp direction exp DO stmt .)


state 209

    (33) vartype -> ARRAY [ LITERAL_INT RANGE LITERAL_INT ] OF vartype .

    (               reduce using rule 33 (vartype -> ARRAY [ LITERAL_INT RANGE LITERAL_INT ] OF vartype .)
    ;               reduce using rule 33 (vartype -> ARRAY [ LITERAL_INT RANGE LITERAL_INT ] OF vartype .)
    EQ              reduce using rule 33 (vartype -> ARRAY [ LITERAL_INT RANGE LITERAL_INT ] OF vartype .)
    )               reduce using rule 33 (vartype -> ARRAY [ LITERAL_INT RANGE LITERAL_INT ] OF vartype .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for ELSE in state 140 resolved as shift
